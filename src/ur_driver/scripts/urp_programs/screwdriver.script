def unnamed():
  global _hidden_verificationVariable=0
  set_target_payload(1.710000, [0.052300, 0.000000, 0.046900], [0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000])
  set_tool_communication(False, 115200, 0, 1, 1.5, 3.5)
  set_tool_output_mode(0)
  set_tool_digital_output_mode(0, 1)
  set_tool_digital_output_mode(1, 1)
  set_tool_voltage(0)
  set_gravity([0.0, 0.0, 9.82])
  set_safety_mode_transition_hardness(1)
  set_tcp(p[0.076,0.0,0.269,0.0,0.0,0.0])
  set_standard_analog_input_domain(0, 1)
  set_standard_analog_input_domain(1, 1)
  set_tool_analog_input_domain(0, 1)
  set_tool_analog_input_domain(1, 1)
  set_analog_outputdomain(0, 0)
  set_analog_outputdomain(1, 0)
  set_input_actions_to_default()
  global nb_vis_reusi=0
  global i_var_1=63
  global count_sec_touch=0
  global count_touch=0
  global erreur_vissage=0
  global perte_vis=0
  global count_vis=500
  global second_time_vis=0
  global rq_show_diag=0
  global count_pick_gig=5
  global count=495
  global should_i_vis=True
  # begin: URCap Installation Node
  #   Source: Robotiq_Screwdriving, 2.2.3.37910-alpha, Robotiq Inc.
  #   Type: Screwdriving
  #--------------------------------------------------------------------------------------------------
  # Screwdriver Constants
  #--------------------------------------------------------------------------------------------------
  RQ_REGULATION_MODE_CURRENT_WITH_RAMP_DOWN = 0
  RQ_REGULATION_MODE_ANGLE = 1
  RQ_REGULATION_MODE_TORQUE = 2
  RQ_REGULATION_MODE_SPEED = 3
  RQ_REGULATION_MODE_CURRENT = 4
  RQ_REGULATION_MODE_TIGHTENING = 5
  RQ_REGULATION_MODE_TORQUE_SPEED_CURRENT = 6
  RQ_ACTIVATE = True
  RQ_DIRECTION_CCW = False
  RQ_DIRECTION_CW = True
  RQ_MODE_NORMAL = False
  RQ_MODE_CALIBRATE = True
  RQ_SCREWDRIVER_ON = True
  RQ_SCREWDRIVER_OFF = False
  RQ_VACUUM_ON = True
  RQ_VACUUM_OFF = False
  RQ_MAX_SUPPLY_CURRENT_MA = 2000
  RQ_IN_ACTION = 0
  RQ_ANGLE_DETECTED = 1
  RQ_TORQUE_DETECTED = 2
  RQ_NO_DETECTION = 3
  RQ_SCREW_STATUS_ACTIVATION_IN_PROGRESS = 1
  RQ_SCREW_STATUS_ACTIVATION_DONE = 3
  RQ_SCREW_SUCCESS = 0
  RQ_SCREW_FAIL_ON_DISTANCE_MIN = 1
  RQ_SCREW_FAIL_ON_DISTANCE_MAX = 2
  RQ_SCREW_FAIL_ON_TIME_MAX = 3
  RQ_SCREW_FAIL_ON_SCREW_NOT_DETECTED = 4
  RQ_SCREW_FAIL_ON_SCREWDRIVER_NOT_ACTIVATED = 5
  RQ_SCREW_FAIL_ON_UNHANDLED_ERROR = 6
  RQ_SCREW_FAIL_ON_SCREWDRIVER_NOT_RESPONDING = 7
  RQ_SCREW_FAIL_ON_SCREWDRIVER_COMMUNICATION_LOST = 8
  RQ_SCREW_FAIL_ON_CONTACT_NOT_FOUND = 9
  RQ_SCREW_FAIL_WITHOUT_DETECTION = 10
  RQ_SCREW_SUCCESS_TEXT = "The screwdriving test is successful."
  RQ_SCREW_SUCCESS_TITLE_TEXT = "Screwdriving Test Success"
  RQ_PICK_SUCCESS = 0
  RQ_PICK_FAIL_ON_SCREW_NOT_READY = 1
  RQ_PICK_FAIL_ON_SCREW_NOT_DETECTED = 2
  RQ_PICK_FAIL_ON_FEEDER_NOT_READY = 3
  RQ_PICK_FAIL_ON_SCREWDRIVER_NOT_ACTIVATED = 5
  RQ_FEEDER_SCREW_PRESENT = 0
  RQ_PICK_SUCCESS_TEXT = "The pick test is successful."
  RQ_PICK_FAIL_ON_SCREW_NOT_READY_TEXT = "Screw not ready in feeder."
  RQ_PICK_FAIL_ON_SCREW_NOT_DETECTED_TEXT = "Screw not detected by screwdriver."
  RQ_PICK_FAIL_ON_FEEDER_NOT_READY_TEXT = "Feeder not ready."
  RQ_PICK_SUCCESS_TITLE_TEXT = "Pick Test Success"
  RQ_PICK_FAILED_TITLE_TEXT = "Pick Test Failed"
  RQ_SCREWDRIVER_NOT_ACTIVATED_TEXT = "Screwdriver is not activated. Please open Screwdriver Toolbar and click on Activate."
  RQ_MILLI_UNIT_TO_UNIT_FACTOR = 1000
  RQ_ENDLESS_TIMEOUT = 0
  RQ_UNUSED_PARAMETER = -1
  RQ_SCREW_FAIL_ON_DISTANCE_MIN_TEXT = "Minimum distance not reached."
  RQ_SCREW_FAIL_ON_DISTANCE_MAX_TEXT = "Maximum distance reached."
  RQ_SCREW_FAIL_ON_TIME_MAX_TEXT = "Maximum time reached."
  RQ_SCREW_FAIL_ON_NO_SCREW_TEXT = "No screw detected"
  RQ_SCREW_FAIL_TITLE = "Test Screw Failed"
  RQ_SCREW_FAIL_ON_UNHANDLED_ERROR_TEXT = "UE0 - Unhandled screw error"
  RQ_SCREW_FAIL_ON_SCREWDRIVER_NOT_RESPONDING_TEXT = "UE1 - Screwdriver not returning proper echo"
  RQ_SCREW_FAIL_ON_SCREWDRIVER_COMMUNICATION_LOST_TEXT = "UE2 - Screwdriver communication lost"
  RQ_SCREW_FAIL_ON_CONTACT_NOT_FOUND_TEXT = "UE3 - Contact with threads not found"
  RQ_SCREW_FAIL_WITHOUT_DETECTION_TEXT = "UE4 - Action finished without detection"
  RQ_TEACHING_OFF = 0
  RQ_TEACHING_ON = 1
  ###################################################
  #
  #  Fault types v2
  #
  ###################################################
  RQ_NO_FAULT = 0
  RQ_APPLICATION_WARNING = 1
  RQ_MOTOR_MINOR_ALARM = 2
  RQ_GENERAL_MINOR_ALARM = 4
  RQ_APPLICATION_MINOR_ALARM = 8
  RQ_MOTOR_MAJOR_ALARM = 16
  RQ_GENERAL_MAJOR_ALARM = 32
  RQ_APPLICATION_MAJOR_ALARM = 64
  RQ_CRITICAL_ALARM = 128

  RQ_NO_FAULT_MESSAGE = "NO_FAULT"
  RQ_APPLICATION_WARNING_MESSAGE = "APPLICATION_WARNING"
  RQ_MOTOR_MINOR_ALARM_MESSAGE = "MOTOR_MINOR_ALARM"
  RQ_GENERAL_MINOR_ALARM_MESSAGE = "GENERAL_MINOR_ALARM"
  RQ_APPLICATION_MINOR_ALARM_MESSAGE = "APPLICATION_MINOR_ALARM"
  RQ_MOTOR_MAJOR_ALARM_MESSAGE = "MOTOR_MAJOR_ALARM"
  RQ_GENERAL_MAJOR_ALARM_MESSAGE = "GENERAL_MAJOR_ALARM"
  RQ_APPLICATION_MAJOR_ALARM_MESSAGE = "APPLICATION_MAJOR_ALARM"
  RQ_CRITICAL_ALARM_MESSAGE = "CRITICAL_ALARM"

  ###################################################
  #
  #  Critical Alarm v2
  #
  ###################################################
  RQ_ACCELEROMETER_INIT = 1
  RQ_MOTOR_PWM_INIT = 2
  RQ_POSITION_SENSOR_INIT = 4
  RQ_GPIO_INIT = 8
  RQ_SOLENOID_INIT = 16
  RQ_FLASH_INIT = 32
  RQ_ADC_INIT = 64

  RQ_ACCELEROMETER_INIT_MESSAGE = "ACCELEROMETER_INIT"
  RQ_MOTOR_PWM_INIT_MESSAGE = "MOTOR_PWM_INIT"
  RQ_POSITION_SENSOR_INIT_MESSAGE = "POSITION_SENSOR_INIT"
  RQ_GPIO_INIT_MESSAGE = "GPIO_INIT"
  RQ_SOLENOID_INIT_MESSAGE = "SOLENOID_INIT"
  RQ_FLASH_INIT_MESSAGE = "FLASH_INIT"
  RQ_ADC_INIT_MESSAGE = "ADC_INIT"

  ###################################################
  #
  #  Application Warnings v2
  #
  ###################################################
  RQ_COMMUNICATION_NOT_READY = 1
  RQ_BLOCKED_AT_START = 2
  RQ_RESTRICTION_BEFORE_ANGLE = 4
  RQ_TIMEOUT = 8
  RQ_REG_WHILE_NOT_ACT = 16
  RQ_NOT_ACTIVATED = 32

  RQ_COMMUNICATION_NOT_READY_MESSAGE = "1 - COMMUNICATION_NOT_READY"
  RQ_BLOCKED_AT_START_MESSAGE = "2 - BLOCKED_AT_START"
  RQ_RESTRICTION_BEFORE_ANGLE_MESSAGE = "4 - RESTRICTION_BEFORE_ANGLE"
  RQ_TIMEOUT_MESSAGE = "8 - TIMEOUT"
  RQ_REGULATION_WHILE_NOT_ACT_MESSAGE = "16 - REGULATION_WHILE_NOT_ACT"
  RQ_NOT_ACTIVATED_MESSAGE = "32 - NOT_ACTIVATED"


  ###################################################
  #
  #  General Minor Alarm v2
  #
  ###################################################

  RQ_OVER_TEMPERATURE_SYSTEM = 2

  RQ_OVER_TEMPERATURE_SYSTEM_MESSAGE = "OVER_TEMPERATURE_SYSTEM"

  ###################################################
  #
  #  General Major Alarm v2
  #
  ###################################################

  RQ_E_STOP = 256
  RQ_OVER_CURRENT_SYSTEM = 512
  RQ_UNDER_VOLTAGE_24V = 1024
  RQ_UNDER_VOLTAGE_8V = 2048
  RQ_UNDER_VOLTAGE_3V = 4096

  RQ_E_STOP_MESSAGE = "E_STOP"
  RQ_OVER_CURRENT_SYSTEM_MESSAGE = "OVER_CURRENT_SYSTEM"
  RQ_UNDER_VOLTAGE_24V_MESSAGE = "UNDER_VOLTAGE_24V"
  RQ_UNDER_VOLTAGE_8V_MESSAGE = "UNDER_VOLTAGE_8V"
  RQ_UNDER_VOLTAGE_3V_MESSAGE = "UNDER_VOLTAGE_3V"

  ###################################################
  #
  #  Motor Minor Alarm v2
  #
  ###################################################
  RQ_CALIBRATION_PHASE_ERROR = 1
  RQ_CALIBRATION_POSITION_ERROR = 2
  RQ_CALIBRATION_PARAMETERS_ERROR = 4

  RQ_CALIBRATION_PHASE_ERROR_MESSAGE = "CALIBRATION_PHASE_ERROR"
  RQ_CALIBRATION_POSITION_ERROR_MESSAGE = "CALIBRATION_POSITION_ERROR"
  RQ_CALIBRATION_PARAMETERS_ERROR_MESSAGE = "CALIBRATION_PARAMETERS_ERROR"
  ###################################################
  #
  #  Motor Major Alarm v2
  #
  ###################################################
  RQ_UNDER_VOLTAGE = 1
  RQ_OVER_VOLTAGE = 2
  RQ_OVER_CURRENT_AC = 4
  RQ_OVER_CURRENT_DC = 8
  RQ_OVER_TEMP = 16
  RQ_POSITION_SENSOR_ERROR = 32
  RQ_PHASE_DRIVER_ERROR = 64
  RQ_PHASE_SENSOR_ERROR = 128

  RQ_UNDER_VOLTAGE_MESSAGE = "UNDER_VOLTAGE"
  RQ_OVER_VOLTAGE_MESSAGE = "OVER_VOLTAGE"
  RQ_OVER_CURRENT_AC_MESSAGE = "OVER_CURRENT_AC"
  RQ_OVER_CURRENT_DC_MESSAGE = "OVER_CURRENT_DC"
  RQ_OVER_TEMP_MESSAGE = "OVER_TEMP"
  RQ_POSITION_SENSOR_ERROR_MESSAGE = "POSITION_SENSOR_ERROR"
  RQ_PHASE_DRIVER_ERROR_MESSAGE = "PHASE_DRIVER_ERROR"
  RQ_PHASE_SENSOR_ERROR_MESSAGE = "PHASE_SENSOR_ERROR"
  global bash = rpc_factory("xmlrpc", "http://127.0.0.1:8000/bash")
  global logging_filename = str_cat("/tmp/screwing_info_",bash.date("+%Y_%m_%d_%H:%M:%S.csv"))
  #--------------------------------------------------------------------------------------------------
  #   Faults               2000[7-0]   Screwdriver fault types:
  #                                   0 = application warnings.[2501]
  #                                   1 = motor minor[2505]
  #                                   2 = general minor[2504]
  #                                   3 = application minor[2502]
  #                                   4 = motor major[2506]
  #                                   5 = general major[2504]
  #                                   6 = application major[2503]
  #                                   7 = critical[2500]
  #--------------------------------------------------------------------------------------------------
  def rq_get_screw_fault(slave_id=9):
    rq_error_list = [0,0,0,0,0,0,0,0]
    registers_200x = rq_comm_read_registers_200x(slave_id, RQ_READ_SCREWDRIVER_REGISTERS_SIZE)
    rq_error_type = registers_200x[0]

    if (rq_error_type == RQ_NO_FAULT):
      return rq_error_list
    end

    registers_250x = rq_comm_read_registers_250x(slave_id)
    rq_application_warnings = rq_extract_boolean_from_register_value(rq_error_type, 0)
    rq_motor_minor = rq_extract_boolean_from_register_value(rq_error_type, 1)
    rq_general_minor = rq_extract_boolean_from_register_value(rq_error_type, 2)
    rq_application_minor = rq_extract_boolean_from_register_value(rq_error_type, 3)
    rq_motor_major = rq_extract_boolean_from_register_value(rq_error_type, 4)
    rq_general_major = rq_extract_boolean_from_register_value(rq_error_type, 5)
    rq_application_major = rq_extract_boolean_from_register_value(rq_error_type, 6)
    rq_critical = rq_extract_boolean_from_register_value(rq_error_type, 7)

    if(rq_application_warnings):
     rq_error_list[0] = rq_extract_value_from_register_value(registers_250x[1], 0, 16)
    end
    if(rq_motor_minor):
     rq_error_list[1] = rq_extract_value_from_register_value(registers_250x[5], 0, 16)
    end
    if(rq_general_minor):
     rq_error_list[2] = rq_extract_value_from_register_value(registers_250x[4], 0, 8)
    end
    if(rq_application_minor):
     rq_error_list[3] = rq_extract_value_from_register_value(registers_250x[2], 0, 16)
    end
    if(rq_motor_major):
     rq_error_list[4] = rq_extract_value_from_register_value(registers_250x[6], 0, 16)
    end
    if(rq_general_major):
     rq_error_list[5] = rq_extract_value_from_register_value(registers_250x[4], 8, 16)
    end
    if(rq_application_major):
     rq_error_list[6] = rq_extract_value_from_register_value(registers_250x[3], 0, 16)
    end
    if(rq_critical):
     rq_error_list[7] = rq_extract_value_from_register_value(registers_250x[0], 0, 16)
    end

    return rq_error_list
  end

  #--------------------------------------------------------------------------------------------------
  #   Activate echo       2000[8]     Echo of the activate
  #--------------------------------------------------------------------------------------------------
  def rq_get_screw_activated_echo(slave_id=9):
      registers_200x = rq_comm_read_registers_200x(slave_id, RQ_READ_SCREWDRIVER_REGISTERS_SIZE)
      return rq_extract_is_screw_activated_echo(registers_200x)
  end
  def rq_extract_is_screw_activated_echo(registers_200x):
      return rq_extract_boolean_from_register_value(registers_200x[0], 8)
  end

  def rq_get_activation_and_screw_detection(slave_id):
    registers_200x = rq_comm_read_registers_200x(slave_id, RQ_READ_SCREWDRIVER_REGISTERS_SIZE)
    activation = rq_extract_is_screw_activated_echo(registers_200x)
    screw_detection = rq_extract_boolean_from_register_value(registers_200x[1], 12)

    return [activation, screw_detection]
  end
  #--------------------------------------------------------------------------------------------------
  #   Direction echo      2000[9]     Echo of the desired direction.
  #--------------------------------------------------------------------------------------------------
  def rq_get_screw_direction_echo(slave_id=9):
      registers_200x = rq_comm_read_registers_200x(slave_id, RQ_READ_SCREWDRIVER_REGISTERS_SIZE)
      return rq_extract_screw_direction_echo(registers_200x)
  end
  def rq_extract_screw_direction_echo(registers_200x):
      return rq_extract_boolean_from_register_value(registers_200x[0], 9)
  end

  #--------------------------------------------------------------------------------------------------
  #   Regulate echo       2000[11]    Echo of the regulate.
  #--------------------------------------------------------------------------------------------------
  def rq_get_screw_regulate_echo(slave_id=9):
      registers_200x = rq_comm_read_registers_200x(slave_id, RQ_READ_SCREWDRIVER_REGISTERS_SIZE)
      return rq_extract_screw_regulate_echo(registers_200x)
  end
  def rq_extract_screw_regulate_echo(registers_200x):
      return rq_extract_boolean_from_register_value(registers_200x[0], 11)
  end

  #--------------------------------------------------------------------------------------------------
  #   Screwdriver status  2000[13-12]     3 = Activation done
  #                                       1 = Activation in progress
  #                                       0 = Else
  #--------------------------------------------------------------------------------------------------
  def rq_get_screw_status(slave_id=9):
      registers_200x = rq_comm_read_registers_200x(slave_id, RQ_READ_SCREWDRIVER_REGISTERS_SIZE)
      return rq_extract_screw_status_echo(registers_200x)
  end
  def rq_extract_screw_status_echo(registers_200x):
      return rq_extract_value_from_register_value(registers_200x[0], 12, 2)
  end
  #--------------------------------------------------------------------------------------------------
  #   Action status       2000[15-14]     0 = initiating/doing an action
  #                                       1 = angle detected
  #                                       2 = torque detected
  #                                       3 = action finished without detection
  #--------------------------------------------------------------------------------------------------
  def rq_get_screw_action(slave_id=9):
      registers_200x = rq_comm_read_registers_200x(slave_id, RQ_READ_SCREWDRIVER_REGISTERS_SIZE)
      return rq_extract_value_from_register_value(registers_200x[0], 14, 2)
  end

  #--------------------------------------------------------------------------------------------------
  #   Regulation mode echo   2001[2-0]    0 = regulates speed, stops at desired current or timeout (ramp down at angle)
  #                                       1 = regulates speed, stops at desired current or timeout
  #                                       2 = regulates speed, stops at desired angle or timeout
  #                                       3 = regulates current, stops at timeout
  #                                       4 = regulates speed, stops at timeout
  #                                       5 = ?
  #                                       6 = regulate torque at stall (internal mode)
  #                                       7 = regultate torque (internal mode)
  #--------------------------------------------------------------------------------------------------
  def rq_get_screw_regulation_mode_echo(slave_id=9):
      registers_200x = rq_comm_read_registers_200x(slave_id, RQ_READ_SCREWDRIVER_REGISTERS_SIZE)
      return rq_extract_regulation_mode_echo(registers_200x)
  end
  def rq_extract_regulation_mode_echo(registers_200x):
      return rq_extract_value_from_register_value(registers_200x[1], 0, 2)
  end

  #--------------------------------------------------------------------------------------------------
  #   Vacuum screw detection 2001[12]     0 = not detected
  #                                       1 = detected
  #--------------------------------------------------------------------------------------------------
  def rq_is_screw_detected(slave_id=9):
      registers_200x = rq_comm_read_registers_200x(slave_id, RQ_READ_SCREWDRIVER_REGISTERS_SIZE)
      return rq_extract_boolean_from_register_value(registers_200x[1], 12)
  end

  #--------------------------------------------------------------------------------------------------
  #   Vacuum echo            2001[13]     0 = close
  #                                       1 = open
  #--------------------------------------------------------------------------------------------------
  def rq_get_screw_vacuum_echo(slave_id=9):
      registers_200x = rq_comm_read_registers_200x(slave_id, RQ_READ_SCREWDRIVER_REGISTERS_SIZE)
      return rq_extract_screw_vacuum_echo(registers_200x)
  end
  def rq_extract_screw_vacuum_echo(registers_200x):
      return rq_extract_boolean_from_register_value(registers_200x[1], 13)
  end

  #--------------------------------------------------------------------------------------------------
  #   Operation mode echo    2001[14]    Echo of the screwdriver mode
  #--------------------------------------------------------------------------------------------------
  def rq_get_screw_operation_mode_echo(slave_id=9):
      registers_200x = rq_comm_read_registers_200x(slave_id, RQ_READ_SCREWDRIVER_REGISTERS_SIZE)
      return rq_extract_screw_operation_mode(registers_200x)
  end
  def rq_extract_screw_operation_mode(registers_200x):
      return rq_extract_boolean_from_register_value(registers_200x[1], 14)
  end

  #--------------------------------------------------------------------------------------------------
  #   Rotation current echo   2002        Desired current to apply. 1 bit = 1 mA
  #--------------------------------------------------------------------------------------------------
  def rq_get_screw_rotation_current_echo_mA(slave_id=9):
      registers_200x = rq_comm_read_registers_200x(slave_id, RQ_READ_SCREWDRIVER_REGISTERS_SIZE)
      return rq_extract_rotation_current_echo(registers_200x)
  end
  def rq_extract_rotation_current_echo(registers_200x):
      return registers_200x[2]
  end

  #--------------------------------------------------------------------------------------------------
  #   Rotation speed echo     2003        Desired rotation speed to regulate in RPM
  #--------------------------------------------------------------------------------------------------
  def rq_get_screw_rotation_speed_echo_rpm(slave_id=9):
      registers_200x = rq_comm_read_registers_200x(slave_id, RQ_READ_SCREWDRIVER_REGISTERS_SIZE)
      return rq_extract_screw_rotation_speed_echo_rpm(registers_200x)
  end
  def rq_extract_screw_rotation_speed_echo_rpm(registers_200x):
      return registers_200x[3]
  end

  #--------------------------------------------------------------------------------------------------
  #   Actual delta angle      2004[15-0]-2005[15-8]    Actual delta angle in degrees
  #--------------------------------------------------------------------------------------------------
  def rq_get_screw_delta_angle_deg(slave_id=9):
      registers_200x = rq_comm_read_registers_200x(slave_id, RQ_READ_SCREWDRIVER_REGISTERS_SIZE)
      register_2005_8_15 = rq_extract_value_from_register_value(registers_200x[5], 8, 8)
      return registers_200x[4] + register_2005_8_15 * pow(2, 16)
  end

  #--------------------------------------------------------------------------------------------------
  #   Desired delta angle      2007[15-0]-2008[15-8]    Desired delta angle in degrees
  #--------------------------------------------------------------------------------------------------
  def rq_get_desired_delta_angle_deg(slave_id=9):
      registers_200x = rq_comm_read_registers_200x(slave_id, RQ_READ_SCREWDRIVER_REGISTERS_SIZE)
      register_2008_8_15 = rq_extract_value_from_register_value(registers_200x[8], 8, 8)
      return registers_200x[7] + register_2008_8_15 * pow(2, 16)
  end

  #--------------------------------------------------------------------------------------------------
  #   Actual current          2005[7-0]  Actual current, 1 bit = 100 mA
  #--------------------------------------------------------------------------------------------------
  def rq_get_screw_current_mA(slave_id=9):
      registers_200x = rq_comm_read_registers_200x(slave_id, RQ_READ_SCREWDRIVER_REGISTERS_SIZE)
      register_2005_0_7 = rq_extract_value_from_register_value(registers_200x[5], 0, 8)
      return register_2005_0_7 * 100
  end

  #--------------------------------------------------------------------------------------------------
  #   Actual rotation speed   2006    Actual rotation speed   RPM
  #--------------------------------------------------------------------------------------------------
  def rq_get_screw_rotation_speed_rpm(slave_id=9):
      registers_200x = rq_comm_read_registers_200x(slave_id, RQ_READ_SCREWDRIVER_REGISTERS_SIZE)
      return registers_200x[6]
  end

  #--------------------------------------------------------------------------------------------------
  #   Torque Threshold        2010
  #--------------------------------------------------------------------------------------------------
  def rq_get_torque_threshold_Nm(slave_id=9):
      registers_200x = rq_comm_read_registers_200x(slave_id, RQ_READ_SCREWDRIVER_REGISTERS_SIZE)
      return rq_extract_torque_threshold_echo(registers_200x) / 10000
  end
  def rq_extract_torque_threshold_echo(registers_200x):
      return rq_convert_unsigned16_to_signed16(registers_200x[10])
  end

  #--------------------------------------------------------------------------------------------------
  #   Torque Angle Slope      2011
  #--------------------------------------------------------------------------------------------------
  def rq_get_torque_slope(slave_id=9):
      registers_200x = rq_comm_read_registers_200x(slave_id, RQ_READ_SCREWDRIVER_REGISTERS_SIZE)
      return rq_extract_torque_angle_slope_echo(registers_200x)
  end
  def rq_extract_torque_angle_slope_echo(registers_200x):
      return rq_convert_unsigned16_to_signed16(registers_200x[11])
  end

  #--------------------------------------------------------------------------------------------------
  #   Torque Gain %     2012  value between 0 and 100. Default is 12
  #--------------------------------------------------------------------------------------------------
  def rq_get_torque_gain_pct(slave_id=9):
      registers = rq_read_registers(slave_id, 2012, 1, rq_xml_rpc_modbus_debug)
      return registers[0]
  end

  #--------------------------------------------------------------------------------------------------
  #   Debug register          6021
  #--------------------------------------------------------------------------------------------------
  def rq_get_screw_register_6021(slave_id=9):
      register_6020 = rq_comm_read_3_registers_6020(slave_id)

      return register_6020[1]
  end

  #--------------------------------------------------------------------------------------------------
  #   Debug register          6022
  #--------------------------------------------------------------------------------------------------
  def rq_get_screw_register_6022(slave_id=9):
      register_6020 = rq_comm_read_3_registers_6020(slave_id)

      return register_6020[2]
  end

  #--------------------------------------------------------------------------------------------------
  # Look for screwdriver activation
  #--------------------------------------------------------------------------------------------------
  def rq_screwdriver_is_activated(slave_id=9):
    registers_200x = rq_comm_read_registers_200x(slave_id, RQ_READ_SCREWDRIVER_REGISTERS_SIZE)

    return (rq_extract_screw_status_echo(registers_200x) == RQ_SCREW_STATUS_ACTIVATION_DONE) and rq_extract_is_screw_activated_echo(registers_200x)
  end

  #--------------------------------------------------------------------------------------------------
  # Returns True when all echo matches parameters
  #--------------------------------------------------------------------------------------------------
  def rq_screwdriver_echo_equal(slave_id, vacuum, rotation_current, regulate, direction, rotation_speed, operation_mode, regulation_mode, torque_threshold, torque_angle_slope):
    registers_200x = rq_comm_read_registers_200x(slave_id, RQ_READ_SCREWDRIVER_REGISTERS_SIZE)

    return (vacuum == rq_extract_screw_vacuum_echo(registers_200x)) and
           (rotation_current == rq_extract_rotation_current_echo(registers_200x)) and
           (regulate == rq_extract_screw_regulate_echo(registers_200x)) and
           (direction == rq_extract_screw_direction_echo(registers_200x)) and
           (rotation_speed == rq_extract_screw_rotation_speed_echo_rpm(registers_200x)) and
           (operation_mode == rq_extract_screw_operation_mode(registers_200x)) and
           (regulation_mode == rq_extract_regulation_mode_echo(registers_200x)) and
           (torque_threshold == rq_extract_torque_threshold_echo(registers_200x)) and
           (torque_angle_slope == rq_extract_torque_angle_slope_echo(registers_200x))

  end

  #--------------------------------------------------------------------------------------------------
  # Refresh registers 200x to get actual communication state. Return communication state.
  #--------------------------------------------------------------------------------------------------
  def rq_is_comm_lost(slave_id):
    rq_comm_read_registers_200x(slave_id, RQ_READ_SCREWDRIVER_REGISTERS_SIZE)

    return rq_comm_lost[rq_comm_slave_id_to_index(slave_id)]
  end

  #--------------------------------------------------------------------------------------------------
  # Returns the magnetic encoder count - Register 4000(LSB) - 4001(MSB)
  #--------------------------------------------------------------------------------------------------
  def rq_get_magnetic_encoder_count(slave_id=9):
      registers_lsb = rq_read_registers(slave_id, 4000, 1, rq_xml_rpc_modbus_debug)
      registers_msb = rq_read_registers(slave_id, 4001, 1, rq_xml_rpc_modbus_debug)

      return (registers_msb[0] * pow(2,16)) + registers_lsb[0]
  end

  #--------------------------------------------------------------------------------------------------
  # Returns the magnetic encoder error flag - Register 4002[15-13]
  #                                                         13 = Framing error
  #                                                         14 = Invalid command error
  #                                                         15 = Parity error
  #--------------------------------------------------------------------------------------------------
  def rq_get_magnetic_encoder_error_flag(slave_id=9):
      registers = rq_read_registers(slave_id, 4002, 1, rq_xml_rpc_modbus_debug)

      if (rq_extract_boolean_from_register_value(registers[0], 13)):
        return "Encoder error - Framing error"
      elif (rq_extract_boolean_from_register_value(registers[0], 14)):
        return "Encoder error - Invalid command error"
      elif (rq_extract_boolean_from_register_value(registers[0], 15)):
        return "Encoder error - Parity error"
      end

      return "No magnetic encoder error"
  end

  #--------------------------------------------------------------------------------------------------
  # Returns the magnetic encoder is ready - Register 4002[8]
  #--------------------------------------------------------------------------------------------------
  def rq_get_magnetic_encoder_ready(slave_id=9):
      registers = rq_read_registers(slave_id, 4002, 1,rq_xml_rpc_modbus_debug)

      return not rq_extract_boolean_from_register_value(registers[0], 8)
  end

  #--------------------------------------------------------------------------------------------------
  # Returns the magnetic encoder field strength - Register 4002[7-0]
  #--------------------------------------------------------------------------------------------------
  def rq_get_magnetic_encoder_field_strength(slave_id=9):
      registers = rq_read_registers(slave_id, 4002, 1, rq_xml_rpc_modbus_debug)

      return rq_extract_value_from_register_value(registers[0], 0, 8)
  end

  #--------------------------------------------------------------------------------------------------
  # Returns the CPU percent max live - Register 4003
  #--------------------------------------------------------------------------------------------------
  def rq_get_cpu_percent_max_live(slave_id=9):
      registers = rq_read_registers(slave_id, 4003, 1,rq_xml_rpc_modbus_debug)

      return registers[0]
  end

  #--------------------------------------------------------------------------------------------------
  # Returns the CPU percent max since boot - Register 4004
  #--------------------------------------------------------------------------------------------------
  def rq_get_cpu_percent_max_since_boot(slave_id=9):
      registers = rq_read_registers(slave_id, 4004, 1, rq_xml_rpc_modbus_debug)

      return registers[0]
  end

  #--------------------------------------------------------------------------------------------------
  # Returns the current motor analog Amps - Register 4005
  #--------------------------------------------------------------------------------------------------
  def rq_get_current_motor_amps(slave_id=9):
      registers = rq_read_registers(slave_id, 4005, 1, rq_xml_rpc_modbus_debug)

      return registers[0]/100
  end

  #--------------------------------------------------------------------------------------------------
  # Returns the analog 24v voltage - Register 4006
  #--------------------------------------------------------------------------------------------------
  def rq_get_analog_24_volt(slave_id=9):
      registers =rq_read_registers(slave_id, 4006, 1, rq_xml_rpc_modbus_debug)

      return registers[0]/100
  end

  #--------------------------------------------------------------------------------------------------
  # Returns the analog 8v8 voltage - Register 4007
  #--------------------------------------------------------------------------------------------------
  def rq_get_analog_8v8_volt(slave_id=9):
      registers = rq_read_registers(slave_id, 4007, 1, rq_xml_rpc_modbus_debug)

      return registers[0]/100
  end

  #--------------------------------------------------------------------------------------------------
  # Returns the microcontroller temperature Celsius - Register 4008
  #--------------------------------------------------------------------------------------------------
  def rq_get_uc_temp_celsius(slave_id=9):
      registers = rq_read_registers(slave_id, 4008, 1, rq_xml_rpc_modbus_debug)

      return registers[0]/100
  end

  #--------------------------------------------------------------------------------------------------
  # Returns the motor temperature Celsius - Register 4009
  #--------------------------------------------------------------------------------------------------
  def rq_get_motor_temp_celsius(slave_id=9):
      registers = rq_read_registers(slave_id, 4009, 1,rq_xml_rpc_modbus_debug)

      return registers[0]/100
  end

  #--------------------------------------------------------------------------------------------------
  # Returns the vacuum pressure Psi - Register 4010
  #--------------------------------------------------------------------------------------------------
  def rq_get_vacuum_pressure_kpa(slave_id=9):
      registers = rq_read_registers(slave_id, 4010, 1, rq_xml_rpc_modbus_debug)

      return rq_convert_unsigned16_to_signed16(registers[0]) / 100
  end

  #--------------------------------------------------------------------------------------------------
  # Returns the estimated load torque - Register 4012
  #--------------------------------------------------------------------------------------------------
  def rq_get_load_nm(slave_id=9):
      registers = rq_read_registers(slave_id, 4012, 1, rq_xml_rpc_modbus_debug)

      return registers[0]/1000
  end

  #--------------------------------------------------------------------------------------------------
  # Returns the estimated maximum load torque - Register 4013
  #--------------------------------------------------------------------------------------------------
  def rq_get_max_load_nm(slave_id=9):
      registers = rq_read_registers(slave_id, 4013, 1, rq_xml_rpc_modbus_debug)

      return registers[0]/1000
  end

  #--------------------------------------------------------------------------------------------------
  # add all diagnostic registers output in Polyscope Log tab.
  #--------------------------------------------------------------------------------------------------
  def rq_log_screw_diag_registers(slave_id=9):
    textmsg("magnetic encoder count : ", rq_get_magnetic_encoder_count(slave_id))
    textmsg("magnetic encoder is ready : ", rq_get_magnetic_encoder_ready(slave_id))
    textmsg("magnetic encoder error flag : ", rq_get_magnetic_encoder_error_flag(slave_id))
    textmsg("magnetic encoder field strength : ", rq_get_magnetic_encoder_field_strength(slave_id))
    textmsg("CPU percent max LIVE : ", rq_get_cpu_percent_max_live(slave_id))
    textmsg("CPU percent max since boot : ", rq_get_cpu_percent_max_since_boot(slave_id))
    textmsg("current motor analog Amps : ", rq_get_current_motor_amps(slave_id))
    textmsg("analog 24v voltage : ", rq_get_analog_24_volt(slave_id))
    textmsg("analog 8v8 voltage : ", rq_get_analog_8v8_volt(slave_id))
    textmsg("microcontroller temp Celsius : ", rq_get_uc_temp_celsius(slave_id))
    textmsg("motor temp Celsius : ", rq_get_motor_temp_celsius(slave_id))
    textmsg("vacuum pressure Kpa : ", rq_get_vacuum_pressure_kpa(slave_id))
    textmsg("estimated load torque Nm LIVE : ", rq_get_load_nm(slave_id))
    textmsg("estimated maximum load torque Nm :", rq_get_max_load_nm(slave_id))
  end

  #--------------------------------------------------------------------------------------------------
  #   Pressure sensor offset        441 (100bit = kPa (signed))
  #                                 pressure_offset in kpa
  #
  #--------------------------------------------------------------------------------------------------
  def get_pressure_sensor_offset(slave_id = 9):
    registers = rq_read_registers(slave_id, 441, 1, rq_xml_rpc_modbus_debug)

    return rq_convert_unsigned16_to_signed16(registers[0]) / 100
  end

  #--------------------------------------------------------------------------------------------------
  # Convert unsigned 16 bits integer to signed 16 bits integer
  #--------------------------------------------------------------------------------------------------
  def rq_convert_unsigned16_to_signed16(value):
    if (value >= 32768):
      return value - 65536
    end
    return value
  end
  #--------------------------------------------------------------------------------------------------
  #   Register            1000        Action request
  #
  #   Regulation mode     1000[2-0]   0 = regulates speed, stops at desired current or timeout
  #                                   1 = regulates speed, with ramp down, stops at desired angle or timeout
  #                                   2-7 = unused
  #   Activate            1000[8]     0 = Resetting errors
  #                                   1 = Allows the screwdriver to do an action
  #   Rotation direction  1000[9]     0 = Clockwise (screwing)
  #                                   1 = Counter-clockwise (unscrewing)
  #   Regulate            1000[11]    0 = doing nothing (stop movement)
  #                                   1 = regulating movement
  #   Teaching            1000[12]    0 = inactive
  #                                   1 = active
  #   Vacuum activation   1000[13]    0 = close
  #                                   1 = open
  #   Operation mode      1000[14]    0 = normal mode (Torque mode)
  #                                   1 = calibration mode (Current Mode)
  #   Command modify      1000[15]    0 = new command
  #                                   1 = modify command
  #--------------------------------------------------------------------------------------------------
  #   Register            1001[15-0]  Max supply current
  #                                   Range 0-65535 (1 bit = 1 mA)
  #--------------------------------------------------------------------------------------------------
  #   Register            1002[15-0]   Desired rotation current
  #                                    Range 0-65535 (1 bit = 1 mA)
  #--------------------------------------------------------------------------------------------------
  #   Register            1003        Desired rotation speed in RPM
  #                                   Range 16bit = 65Krpm
  #--------------------------------------------------------------------------------------------------
  #   Register            1004[15-0]-1005[15-8]   Desired rotation delta angle
  #                                               Desired delta angle to attain
  #                                               24bit = 46 kdegrees
  #--------------------------------------------------------------------------------------------------
  #   Register            1005[7-0]   Rotation timeout
  #                                   Timeout of regulated movement (8bit = 25.5s), 1bit = 0.1s
  #--------------------------------------------------------------------------------------------------
  #   Register            1006        Torque Threshold
  #
  #--------------------------------------------------------------------------------------------------
  #   Register            1007        Torque Angle Slope
  #
  #--------------------------------------------------------------------------------------------------
  def rq_set_screw_registers_100x(slave_id, regulation_mode, activate, direction, operation_mode, regulate, teaching,
  vacuum, rotation_current, max_supply_current_mA, rotation_speed_rpm, rotation_delta_angle, rotation_timeout_ms,
  torque_threshold, torque_angle_slope, modify_command = False):
      registers_100x = [0, 0, 0, 0, 0, 0, 0, 0]
      registers_100x[0] = rq_insert_value_in_register_value(registers_100x[0], 0, 3, regulation_mode)
      registers_100x[0] = rq_insert_boolean_in_register_value(registers_100x[0], 8, activate)
      registers_100x[0] = rq_insert_boolean_in_register_value(registers_100x[0], 9, direction)
      registers_100x[0] = rq_insert_boolean_in_register_value(registers_100x[0], 11, regulate)
      registers_100x[0] = rq_insert_value_in_register_value(registers_100x[0], 12, 1, teaching)
      registers_100x[0] = rq_insert_boolean_in_register_value(registers_100x[0], 13, vacuum)
      registers_100x[0] = rq_insert_boolean_in_register_value(registers_100x[0], 14, operation_mode)
      registers_100x[0] = rq_insert_boolean_in_register_value(registers_100x[0], 15, modify_command)

      registers_100x[1] = max_supply_current_mA

      registers_100x[2] = rotation_current

      registers_100x[3] = rotation_speed_rpm

      rotation_angle_lsb = floor(rotation_delta_angle % pow(2, 16))
      rotation_angle_msb = floor((rotation_delta_angle -  rotation_angle_lsb) / pow(2, 16))

      registers_100x[4] = rotation_angle_lsb
      registers_100x[5] = rq_insert_msb_in_register_value(registers_100x[5], rotation_angle_msb)
      registers_100x[5] = rq_insert_lsb_in_register_value(registers_100x[5], floor(rotation_timeout_ms / 100))

      registers_100x[6] = torque_threshold
      registers_100x[7] = torque_angle_slope

      rq_comm_write_registers_100x(slave_id, registers_100x, 8)
  end

  #--------------------------------------------------------------------------------------------------
  #   Activate screwdriver, sequence:
  #   1 - Reset screwdriver (activate = False) and wait echo
  #   2 - Activate screwdriver (activate = True) and wait echo and status
  #--------------------------------------------------------------------------------------------------
  def rq_screw_activate(slave_id = 9):
      while(rq_get_screw_activated_echo(slave_id)):
          registers_100x = rq_comm_get_registers_100x(slave_id, 8)
          registers_100x[0] = rq_insert_boolean_in_register_value(registers_100x[0], 8, False)
          rq_comm_write_registers_100x(slave_id, registers_100x, 8)
          sleep(0.1)
      end

      while(not rq_get_screw_activated_echo(slave_id) or rq_get_screw_status(slave_id) != RQ_SCREW_STATUS_ACTIVATION_DONE):
          registers_100x = rq_comm_get_registers_100x(slave_id, 8)
          registers_100x[0] = rq_insert_boolean_in_register_value(registers_100x[0], 8, True)
          rq_comm_write_registers_100x(slave_id, registers_100x, 8)
          sleep(0.1)
      end
  end

  #--------------------------------------------------------------------------------------------------
  #   Regulate            1000[11]    0 = doing nothing (stop movement)
  #                                   1 = regulating movement
  #--------------------------------------------------------------------------------------------------
  def rq_set_screw_regulate(slave_id, regulate):
      registers_100x = rq_comm_get_registers_100x(slave_id, 8)
      registers_100x[0] = rq_insert_boolean_in_register_value(registers_100x[0], 11, regulate)
      rq_comm_write_registers_100x(slave_id, registers_100x, 8)
  end

  #--------------------------------------------------------------------------------------------------
  #   Torque gain %            1008   torque gain is a value between 0 and 100. The default value is 12.
  #
  #--------------------------------------------------------------------------------------------------
  def rq_set_torque_gain_pct(torque_gain = 12, slave_id=9):
    rq_write_registers(slave_id, 1008, [torque_gain], rq_xml_rpc_modbus_debug)
  end

  #--------------------------------------------------------------------------------------------------
  #   Vacuum command on
  #--------------------------------------------------------------------------------------------------
  def rq_screw_vacuum_on(slave_id = 9):
      rq_set_screw_vacuum(True, slave_id)
  end

  #--------------------------------------------------------------------------------------------------
  #   Vacuum command off
  #--------------------------------------------------------------------------------------------------
  def rq_screw_vacuum_off(slave_id = 9):
      rq_set_screw_vacuum(False, slave_id)
  end

  #--------------------------------------------------------------------------------------------------
  #   Vacuum command off and regulate to false
  #--------------------------------------------------------------------------------------------------

  def rq_screw_vacuum_off_and_stop_regulate(slave_id=9):
    registers_100x = rq_comm_get_registers_100x(slave_id, 8)
    registers_200x = rq_comm_read_registers_200x(slave_id, RQ_READ_SCREWDRIVER_REGISTERS_SIZE)

    activate = rq_extract_boolean_from_register_value(registers_200x[0], 8)
    rotation_direction = rq_extract_boolean_from_register_value(registers_200x[0], 9)
    regulation_mode = rq_extract_value_from_register_value(registers_200x[1], 0, 2)
    operation_mode = rq_extract_value_from_register_value(registers_200x[1], 14, 1)
    regulate = False
    vacuum = False

    registers_100x[0] = rq_insert_value_in_register_value(registers_100x[0], 0, 2, regulation_mode)
    registers_100x[0] = rq_insert_boolean_in_register_value(registers_100x[0], 8, activate)
    registers_100x[0] = rq_insert_boolean_in_register_value(registers_100x[0], 9, rotation_direction)
    registers_100x[0] = rq_insert_boolean_in_register_value(registers_100x[0], 11, regulate)
    registers_100x[0] = rq_insert_boolean_in_register_value(registers_100x[0], 13, vacuum)
    registers_100x[0] = rq_insert_value_in_register_value(registers_100x[0], 14, 2, operation_mode)

    rq_comm_write_registers_100x(slave_id, registers_100x, 8)
  end

  #--------------------------------------------------------------------------------------------------
  #   Vacuum command         1000[13]     0 = close
  #                                       1 = open
  #--------------------------------------------------------------------------------------------------
  def rq_set_screw_vacuum(vacuum, slave_id = 9):
    registers_100x = rq_comm_get_registers_100x(slave_id, 8)
    registers_200x = rq_comm_read_registers_200x(slave_id, RQ_READ_SCREWDRIVER_REGISTERS_SIZE)

    activate = rq_extract_boolean_from_register_value(registers_200x[0], 8)
    rotation_direction = rq_extract_boolean_from_register_value(registers_200x[0], 9)
    regulate = rq_extract_boolean_from_register_value(registers_200x[0], 11)
    regulation_mode = rq_extract_value_from_register_value(registers_200x[1], 0, 2)
    operation_mode = rq_extract_value_from_register_value(registers_200x[1], 14, 1)

    registers_100x[0] = rq_insert_value_in_register_value(registers_100x[0], 0, 2, regulation_mode)
    registers_100x[0] = rq_insert_boolean_in_register_value(registers_100x[0], 8, activate)
    registers_100x[0] = rq_insert_boolean_in_register_value(registers_100x[0], 9, rotation_direction)
    registers_100x[0] = rq_insert_boolean_in_register_value(registers_100x[0], 11, regulate)
    registers_100x[0] = rq_insert_boolean_in_register_value(registers_100x[0], 13, vacuum)
    registers_100x[0] = rq_insert_value_in_register_value(registers_100x[0], 14, 2, operation_mode)

    rq_comm_write_registers_100x(slave_id, registers_100x, 8)
  end

  #--------------------------------------------------------------------------------------------------
  #   Set Pressure sensor offset        441 (100bit = kPa (signed))
  #                                      pressure_offset in kpa
  #
  #--------------------------------------------------------------------------------------------------
  def set_pressure_sensor_offset(pressure_offset=0, slave_id = 9):
    SAVE_PRESSURE_OFFSET = 56
    KPA_TO_BIT = 100

    offset_in_bit = rq_convert_unsigned32_to_signed16(pressure_offset * KPA_TO_BIT)
    rq_write_registers(slave_id, 441, [offset_in_bit], rq_xml_rpc_modbus_debug)

    save_pressure_offset_msb = floor(SAVE_PRESSURE_OFFSET * pow(2,8))
    rq_write_registers(slave_id, 440, [save_pressure_offset_msb], rq_xml_rpc_modbus_debug)
  end

  #--------------------------------------------------------------------------------------------------
  # Convert unsigned 32 bits integer to signed 16 bits integer
  #--------------------------------------------------------------------------------------------------
  def rq_convert_unsigned32_to_signed16(value):
    if (value < 0):
      return value + 65536
    end
    return value
  end

  #--------------------------------------------------------------------------------------------------
  #   Reset Pressure sensor offset to ambient pressure       440
  #
  #--------------------------------------------------------------------------------------------------
  def reset_pressure_sensor_offset(slave_id = 9):
    RESET_PRESSURE_OFFSET = 131

    reset_pressure_offset_msb = floor(RESET_PRESSURE_OFFSET * pow(2,8))
    rq_write_registers(slave_id, 440, [reset_pressure_offset_msb], rq_xml_rpc_modbus_debug)
  end
  global rq_feeder_timeout = 90
  global rq_pick_rotation_speed = 200

  def rq_is_feeder_screw_ready(ready_input):
    return get_standard_digital_in(ready_input)
  end

  def rq_is_feeder_status_ok(feeder_status):
    return get_standard_digital_in(feeder_status)
  end

  def rq_wait_for_feeder_status_ok(feeder_status, timeout):
    time_step = 0.008

    if(not rq_is_feeder_status_ok(feeder_status)):
      textmsg("Waiting for feeder status.")
    end

    while((not rq_is_feeder_status_ok(feeder_status)) and (timeout > 0)):
          sleep(time_step)
          timeout = timeout - time_step
    end

    return rq_is_feeder_status_ok(feeder_status)
  end

  def rq_pick_screw(screw_pose, status_input, ready_input, test_in_action=False, approach_dist=10, rotation_speed=rq_pick_rotation_speed,
  pick_speed=25, timeout=rq_feeder_timeout, retract_speed=40, direction=RQ_DIRECTION_CCW, slave_id=9):
      global thread_slave_id = slave_id
      global thread_rotation_speed = rotation_speed
      global thread_direction = direction

      rq_screwdriver_index = rq_comm_slave_id_to_index(slave_id)
      approach_dist_m = norm(approach_dist) / 1000
      pick_speed_m = pick_speed / 1000
      retract_speed_m = retract_speed / 1000
      approach_in_screw_frame = p[0, 0, -approach_dist_m, 0, 0, 0]

      def move_to_approach(screw_pose_in_base_frame, approach_in_screw_frame, blend=True):
        approach_in_base_frame = pose_trans(screw_pose_in_base_frame, approach_in_screw_frame)
        dist_to_approach = point_dist(get_actual_tcp_pose(), approach_in_base_frame)
        offset = 0.005
        blend_radius = offset * 0.99
        if blend and (dist_to_approach > blend_radius):
          approach_to_blend_in_base_frame = pose_trans(approach_in_base_frame, p[0, 0, -offset, 0, 0, 0])
          movel(approach_to_blend_in_base_frame, r=blend_radius)
        else:
          movel(approach_in_base_frame)
        end
      end

      def move_to_retract_servoj(ready_input, robot_speed, slave_id):
        max_distance = 0.05
        linear_speed = -robot_speed
        time_step = 0.008
        initial_pose = get_actual_tcp_pose()
        linear_step = linear_speed * time_step
        distance = 0

        while(get_standard_digital_in(ready_input)):
          distance = distance + linear_step
          next_pose = pose_trans(initial_pose, p[0, 0, distance, 0, 0, 0])
          next_joint_position = get_inverse_kin(next_pose)
          servoj(next_joint_position, t=time_step)

          if (norm(distance) >= max_distance):
            break
          end
        end
        stopj(2)
      end

      def move_to_screw(screw_pose_in_base_frame, robot_speed):
          movel(screw_pose_in_base_frame, v = robot_speed)
      end

      thread start_screwdriver_thread():
        torque_Nm = 1
        rotation_current_mA = floor(torque_Nm * 100)
        rotation_delta_angle = 100
        rotation_timeout_ms = 0
        torque_threshold = 0
        torque_angle_slope = 0
        retries = 40

        rq_set_screw_registers_100x(thread_slave_id, RQ_REGULATION_MODE_SPEED, RQ_ACTIVATE, thread_direction,
        RQ_MODE_NORMAL, RQ_SCREWDRIVER_ON, RQ_TEACHING_OFF, RQ_VACUUM_ON, rotation_current_mA, RQ_MAX_SUPPLY_CURRENT_MA,
        thread_rotation_speed, rotation_delta_angle, rotation_timeout_ms, torque_threshold, torque_angle_slope)

        while (not rq_screwdriver_echo_equal(thread_slave_id, RQ_VACUUM_ON, rotation_current_mA, RQ_SCREWDRIVER_ON,
        thread_direction, thread_rotation_speed, RQ_MODE_NORMAL, RQ_REGULATION_MODE_SPEED, torque_threshold, torque_angle_slope)):
          if ((retries <= 0) or (rq_comm_lost[rq_comm_slave_id_to_index(thread_slave_id)])):
            break
          end
          sleep(0.008)
          rq_set_screw_registers_100x(thread_slave_id, RQ_REGULATION_MODE_SPEED, RQ_ACTIVATE, thread_direction,
          RQ_MODE_NORMAL, RQ_SCREWDRIVER_ON, RQ_TEACHING_OFF, RQ_VACUUM_ON, rotation_current_mA, RQ_MAX_SUPPLY_CURRENT_MA,
           thread_rotation_speed, rotation_delta_angle, rotation_timeout_ms, torque_threshold, torque_angle_slope)
          retries = retries - 1
        end
      end

      def stop_screwdriver(slave_id = 9):
          rotation_current_mA = 0
          rotation_delta_angle = 100
          rotation_timeout_ms = 0
          rotation_speed_rpm = 0
          torque_threshold = 0
          torque_angle_slope = 0

          rq_set_screw_registers_100x(slave_id, RQ_REGULATION_MODE_SPEED, RQ_ACTIVATE, RQ_DIRECTION_CW, RQ_MODE_NORMAL,
          RQ_SCREWDRIVER_OFF, RQ_TEACHING_OFF, RQ_VACUUM_ON, rotation_current_mA, RQ_MAX_SUPPLY_CURRENT_MA,
          rotation_speed_rpm, rotation_delta_angle, rotation_timeout_ms, torque_threshold, torque_angle_slope)

          while (RQ_SCREWDRIVER_ON == rq_get_screw_regulate_echo(slave_id)):
            if(rq_comm_lost[rq_comm_slave_id_to_index(slave_id)]):
              break
            end
            sleep(0.008)
            rq_set_screw_registers_100x(slave_id, RQ_REGULATION_MODE_SPEED, RQ_ACTIVATE, RQ_DIRECTION_CW, RQ_MODE_NORMAL,
            RQ_SCREWDRIVER_OFF,  RQ_TEACHING_OFF, RQ_VACUUM_ON, rotation_current_mA, RQ_MAX_SUPPLY_CURRENT_MA,
            rotation_speed_rpm, rotation_delta_angle, rotation_timeout_ms, torque_threshold, torque_angle_slope)
          end
      end

      def wait_for_screw_present(status_input, ready_input, timeout):
        time_step = 1
        screw_ready = get_standard_digital_in(ready_input)

        while(not screw_ready):
          if (timeout <= 0):
            feeder_status = get_standard_digital_in(status_input)
            if (not feeder_status):
              return RQ_PICK_FAIL_ON_FEEDER_NOT_READY
            end
            return RQ_PICK_FAIL_ON_SCREW_NOT_READY
          end
          sleep(time_step)
          timeout = timeout - time_step
          screw_ready = get_standard_digital_in(ready_input)
        end

        return RQ_FEEDER_SCREW_PRESENT
      end

      thread stop_vacuum_thread():
        rq_set_screw_vacuum(False, thread_slave_id)
         while (RQ_VACUUM_ON == rq_get_screw_vacuum_echo(thread_slave_id)):
           if(rq_comm_lost[rq_comm_slave_id_to_index(thread_slave_id)]):
             break
           end
           sleep(0.008)
           rq_set_screw_vacuum(False, thread_slave_id)
         end
      end

      thread screw_detection():
        global screw_detected_flag = False
        index = rq_comm_slave_id_to_index(thread_slave_id)
        while (not rq_is_screw_detected(thread_slave_id)):
          if(rq_comm_lost[index]):
            break
          end
          global screw_detected_flag = False
          sleep(0.008)
        end
        global screw_detected_flag = not rq_comm_lost[index]
      end

      def start_screw_detection():
        global screw_detected_flag = False
        return run screw_detection()
      end

      def screw_detected():
        return screw_detected_flag
      end

      def wait_for_screw_detected(timeout):
        time_step = 0.1
        detected = False
        thread_id = start_screw_detection()
        while (timeout >= 0):
          sleep(time_step)
          timeout = timeout - time_step
          if (screw_detected()):
            detected = True
            break
          end
        end
        kill thread_id
        return detected
      end

      thread peck():
        while (True):
          movel(pose_trans(get_target_tcp_pose(), p[0, 0, -0.004, 0, 0, 0]), a=0.15, v=0.25)
          movel(pose_trans(get_target_tcp_pose(), p[0, 0, 0.004, 0, 0, 0]), a=0.15, v=0.25)
        end
      end

    #--------------------------------------------------------------------------------------------------
    # Process begins here
    #--------------------------------------------------------------------------------------------------
      if ((not test_in_action) and (rq_wait_for_feeder_status_ok(status_input, timeout))):
        stop_vacuum_thread_id = run stop_vacuum_thread()
        move_to_approach(screw_pose, approach_in_screw_frame)
        join stop_vacuum_thread_id
        if (rq_comm_lost[rq_screwdriver_index]):
          textmsg(RQ_SCREW_FAIL_ON_SCREWDRIVER_COMMUNICATION_LOST_TEXT)

          return RQ_SCREW_FAIL_ON_SCREWDRIVER_COMMUNICATION_LOST
        end
      elif(not rq_is_feeder_status_ok(status_input)):
        sleep(0.008)
        return RQ_PICK_FAIL_ON_FEEDER_NOT_READY
      end

      if ((not rq_is_feeder_screw_ready(ready_input)) and (rq_wait_for_feeder_status_ok(status_input, timeout))):
        move_to_approach(screw_pose, approach_in_screw_frame, blend=False)
      elif(not rq_is_feeder_status_ok(status_input)):
        return RQ_PICK_FAIL_ON_FEEDER_NOT_READY
      end

      feeder_result = wait_for_screw_present(status_input, ready_input, timeout)
      if (RQ_FEEDER_SCREW_PRESENT != feeder_result):
          return feeder_result
      end

      start_screwdriver_thread_id = run start_screwdriver_thread()
      move_to_screw(screw_pose, pick_speed_m)
      join start_screwdriver_thread_id

      if (rq_comm_lost[rq_screwdriver_index]):
        textmsg(RQ_SCREW_FAIL_ON_SCREWDRIVER_COMMUNICATION_LOST_TEXT)
        kill start_screwdriver_thread_id

        return RQ_SCREW_FAIL_ON_SCREWDRIVER_COMMUNICATION_LOST
      end

      if (not rq_screwdriver_is_activated(slave_id)):
        return RQ_PICK_FAIL_ON_SCREWDRIVER_NOT_ACTIVATED
      end

      peck_thread_id = run peck()
      wait_for_screw_detected(2)
      kill peck_thread_id
      move_to_retract_servoj(ready_input, retract_speed_m, slave_id)
      is_screw_detected = wait_for_screw_detected(2)
      stop_screwdriver(slave_id)

      if (rq_comm_lost[rq_screwdriver_index]):
        textmsg(RQ_SCREW_FAIL_ON_SCREWDRIVER_COMMUNICATION_LOST_TEXT)

        return RQ_SCREW_FAIL_ON_SCREWDRIVER_COMMUNICATION_LOST
      end
      if (not is_screw_detected):
          return RQ_PICK_FAIL_ON_SCREW_NOT_DETECTED
      end

      return RQ_PICK_SUCCESS
  end
  global rq_screwdriver_faults = [0,0,0,0,0,0,0,0]
  global rq_max_thread_contact_distance = 0.05
  global rq_unhandled_error = RQ_NO_FAULT
  global rq_fs_speed = 0.008
  global rq_log_screwing = False
  copilot_kinematics_rpc_server = rpc_factory("xmlrpc","http://localhost:4251/")
  global app_time = 0
  global rq_find_surface_time = 0
  global rq_screwing_time = 0

  thread app_timer():
    step_time = get_steptime()
    app_time = 0
    while(True):
      app_time = app_time + step_time
      sleep(step_time)
    end
  end

  def rq_screw(operation_mode, regulation_mode, rotation_current, rotation_speed, rotation_angle, timeout, teaching,
  torque_threshold, torque_angle_slope, direction=RQ_DIRECTION_CW, slave_id=9):
    direction = direction
    activation = RQ_ACTIVATE
    regulate = RQ_SCREWDRIVER_ON
    vacuum = rq_get_screw_vacuum_echo(slave_id)
    rotation_speed_raw = rotation_speed
    max_supply_current = RQ_MAX_SUPPLY_CURRENT_MA
    time_max = timeout * 1000
    index = rq_comm_slave_id_to_index(slave_id)

    if(timeout == RQ_UNUSED_PARAMETER):
      time_max = RQ_ENDLESS_TIMEOUT
    end

    retries = 40
    rq_set_screw_registers_100x(slave_id, regulation_mode, activation, direction, operation_mode, regulate, teaching, vacuum,
                                rotation_current, max_supply_current, rotation_speed_raw, rotation_angle, time_max,
                                torque_threshold, torque_angle_slope)
    while (not rq_screwdriver_echo_equal(slave_id, vacuum, rotation_current, regulate, direction, rotation_speed_raw, operation_mode, regulation_mode, torque_threshold, torque_angle_slope)):
      if ((retries <= 0) or (rq_comm_lost[index])):
        return False
      end
      sleep(0.008)
      rq_set_screw_registers_100x(slave_id, regulation_mode, activation, direction, operation_mode, regulate, teaching, vacuum,
                                  rotation_current, max_supply_current, rotation_speed_raw, rotation_angle, time_max,
                                  torque_threshold, torque_angle_slope)
      retries = retries - 1
    end
     return True
  end

  def rq_screw_with_force(operation_mode, regulation_mode, rotation_current, rotation_speed, rotation_angle,
  teach_thread_mating_position, teach_final_position, teaching, torque_threshold, torque_angle_slope, force=10,
  timeout=10, distance_tolerance=0, direction=RQ_DIRECTION_CW, slave_id=9):
    app_timer_id = -1
    if(rq_log_screwing):
      app_timer_id = run app_timer()
    end

    def kill_app_timer(app_timer_id):
      if(rq_log_screwing):
        kill app_timer_id
      end
    end

    thread action_status_thread():
      while (True):
        thread_action_status = rq_get_screw_action(thread_slave_id)
        if (rq_comm_lost[rq_comm_slave_id_to_index(thread_slave_id)]):
          break
        end
      end
    end

    global find_surface_turn_direction = direction
    thread start_find_surface_screwdriver():
      rq_screw_turn(regulation_mode=RQ_REGULATION_MODE_SPEED, torque_Nm=1, rotation_angle=0, rotation_speed_rpm=100, direction=not find_surface_turn_direction, slave_id=thread_slave_id)
    end

    def is_enabled(parameter):
      return parameter > RQ_UNUSED_PARAMETER
    end

    global thread_slave_id = slave_id
    rq_unhandled_error = RQ_NO_FAULT
    rq_screwdriver_index = rq_comm_slave_id_to_index(slave_id)

    global rq_actual_thread_mating_position = get_actual_tcp_pose()

    if (rq_is_comm_lost(slave_id)):
      textmsg(RQ_SCREW_FAIL_ON_SCREWDRIVER_COMMUNICATION_LOST_TEXT)
      rq_unhandled_error = RQ_SCREW_FAIL_ON_SCREWDRIVER_COMMUNICATION_LOST
      kill_app_timer(app_timer_id)

      return RQ_SCREW_FAIL_ON_SCREWDRIVER_COMMUNICATION_LOST
    end

    activation_and_screw_detection_registers = rq_get_activation_and_screw_detection(slave_id)

    if (not activation_and_screw_detection_registers[0]):
      textmsg(RQ_NOT_ACTIVATED_MESSAGE)
      kill_app_timer(app_timer_id)

      return RQ_SCREW_FAIL_ON_SCREWDRIVER_NOT_ACTIVATED
    end

    if(not activation_and_screw_detection_registers[1]):
      textmsg(RQ_SCREW_FAIL_ON_NO_SCREW_TEXT)
      kill_app_timer(app_timer_id)

      return RQ_SCREW_FAIL_ON_SCREW_NOT_DETECTED
    end

    before_find_surface_time = app_time
    start_find_surface_screwdriver_id = run start_find_surface_screwdriver()

    success = rq_wait_for_contact_with_thread(rq_max_thread_contact_distance, rq_fs_speed)
    if (not success):
      kill start_find_surface_screwdriver_id
      rq_screw_stop()
      textmsg(RQ_SCREW_FAIL_ON_CONTACT_NOT_FOUND_TEXT)
      rq_unhandled_error = RQ_SCREW_FAIL_ON_CONTACT_NOT_FOUND
      kill_app_timer(app_timer_id)

      return RQ_SCREW_FAIL_ON_CONTACT_NOT_FOUND
    end

    rq_find_surface_time = app_time - before_find_surface_time

    kill start_find_surface_screwdriver_id

    rq_actual_thread_mating_position = get_actual_tcp_pose()

    if(not rq_is_screw_detected(slave_id)):
      rq_screw_stop()
      textmsg(RQ_SCREW_FAIL_ON_NO_SCREW_TEXT)
      kill_app_timer(app_timer_id)

      return RQ_SCREW_FAIL_ON_SCREW_NOT_DETECTED
    end

    before_screwing_time = app_time
    result = rq_screw(operation_mode, regulation_mode, rotation_current, rotation_speed, rotation_angle, timeout,
    teaching, torque_threshold, torque_angle_slope, direction, slave_id)
    if (result == False):
      if (rq_comm_lost[rq_screwdriver_index]):
        textmsg(RQ_SCREW_FAIL_ON_SCREWDRIVER_COMMUNICATION_LOST_TEXT)
        rq_unhandled_error = RQ_SCREW_FAIL_ON_SCREWDRIVER_COMMUNICATION_LOST
        kill_app_timer(app_timer_id)

        return RQ_SCREW_FAIL_ON_SCREWDRIVER_COMMUNICATION_LOST
      else:
        textmsg(RQ_SCREW_FAIL_ON_SCREWDRIVER_NOT_RESPONDING_TEXT)
        rq_unhandled_error = RQ_SCREW_FAIL_ON_SCREWDRIVER_NOT_RESPONDING
        rq_screw_stop()
        kill_app_timer(app_timer_id)

        return RQ_SCREW_FAIL_ON_SCREWDRIVER_NOT_RESPONDING
      end

    end
    global thread_action_status = RQ_IN_ACTION
    action_status_thread_id = run action_status_thread()

    rq_speed_slider = copilot_kinematics_rpc_server.gettargetspeedfraction()
    if(rq_speed_slider < 1.0):
      copilot_kinematics_rpc_server.settargetspeedfraction(1.0)
    end

    follow_time_step = 0.008

    force_node_thread_id = rq_setup_screw_force(force)

    teach_final_pose_in_thread_frame = pose_trans(pose_inv(teach_thread_mating_position), teach_final_position)

    while (thread_action_status == RQ_IN_ACTION):
      sleep(follow_time_step)
      if (rq_comm_lost[rq_screwdriver_index]):
        kill action_status_thread_id
        kill force_node_thread_id
        kill_app_timer(app_timer_id)

        textmsg(RQ_SCREW_FAIL_ON_SCREWDRIVER_COMMUNICATION_LOST_TEXT)
        rq_unhandled_error = RQ_SCREW_FAIL_ON_SCREWDRIVER_COMMUNICATION_LOST
        copilot_kinematics_rpc_server.settargetspeedfraction(rq_speed_slider)

        return RQ_SCREW_FAIL_ON_SCREWDRIVER_COMMUNICATION_LOST
      end

      if(is_enabled(distance_tolerance)):
        tool_position = get_actual_tcp_pose()
        actual_tool_pose_in_thread_frame = pose_trans(pose_inv(rq_actual_thread_mating_position), tool_position)

        position_delta = actual_tool_pose_in_thread_frame[2] - teach_final_pose_in_thread_frame[2]

        if(position_delta > (distance_tolerance / RQ_MILLI_UNIT_TO_UNIT_FACTOR)):
          copilot_kinematics_rpc_server.settargetspeedfraction(rq_speed_slider)

          kill action_status_thread_id
          kill force_node_thread_id
          kill_app_timer(app_timer_id)

          rq_screw_stop()
          textmsg(RQ_SCREW_FAIL_ON_DISTANCE_MAX_TEXT)

          return RQ_SCREW_FAIL_ON_DISTANCE_MAX
        end
      end
    end

    rq_screwing_time = app_time - before_screwing_time
    if(rq_speed_slider < 1.0):
      copilot_kinematics_rpc_server.settargetspeedfraction(rq_speed_slider)
    end

    kill action_status_thread_id
    kill force_node_thread_id

    if (rq_comm_lost[rq_screwdriver_index]):
      textmsg(RQ_SCREW_FAIL_ON_SCREWDRIVER_COMMUNICATION_LOST_TEXT)
      rq_unhandled_error = RQ_SCREW_FAIL_ON_SCREWDRIVER_COMMUNICATION_LOST
      kill_app_timer(app_timer_id)

      return RQ_SCREW_FAIL_ON_SCREWDRIVER_COMMUNICATION_LOST
    end

    rq_screwdriver_faults = rq_get_screw_fault()
    rq_log_application_warning(rq_screwdriver_faults)
    actual_final_position = get_actual_tcp_pose()

    kill_app_timer(app_timer_id)

    return rq_get_screw_with_force_result(regulation_mode, thread_action_status,
    teach_thread_mating_position, teach_final_position, rq_actual_thread_mating_position, actual_final_position,
    distance_tolerance, timeout, rq_screwdriver_faults)
  end

  #--------------------------------------------------------------------------------------------------
  # Returns screw with a clutch result
  #
  #    action_status          : action status from screwdriver
  #    time                   : elapsed time
  #    time_max               : maximum time elapsed to deem screw operation successful
  #    distance_tolerance     : distance tolerance wanted
  #    rotations_tolerance    : number of rotations wanted
  #    rotations_min          : minimum number of rotations to deem screw operation successful
  #    rotations_max          : maximum number of rotations to deem screw operation successful
  #
  #--------------------------------------------------------------------------------------------------
  def rq_get_screw_with_force_result(regulation_mode, action_status, teach_thread_mating_position,
  teach_final_position, actual_thread_mating_position, actual_final_position, distance_tolerance, timeout, screwdriver_faults):

    def is_enabled(parameter):
        return parameter > RQ_UNUSED_PARAMETER
    end

    teach_final_pose_in_thread_frame = pose_trans(pose_inv(teach_thread_mating_position), teach_final_position)
    actual_final_pose_in_thread_frame = pose_trans(pose_inv(actual_thread_mating_position), actual_final_position)

    position_delta = actual_final_pose_in_thread_frame[2] - teach_final_pose_in_thread_frame[2]

    if(is_enabled(timeout) and timeout > 0 and rq_is_timeout_cause()):
      return RQ_SCREW_FAIL_ON_TIME_MAX
    elif(is_enabled(distance_tolerance) and (position_delta > (distance_tolerance / RQ_MILLI_UNIT_TO_UNIT_FACTOR))):
      return RQ_SCREW_FAIL_ON_DISTANCE_MAX
    elif(is_enabled(distance_tolerance) and (position_delta < -(distance_tolerance / RQ_MILLI_UNIT_TO_UNIT_FACTOR))):
      return RQ_SCREW_FAIL_ON_DISTANCE_MIN
    elif(rq_screwdriver_in_fault(screwdriver_faults)):
      textmsg("Faults : ", screwdriver_faults)
      return RQ_SCREW_FAIL_ON_UNHANDLED_ERROR
    elif(action_status == RQ_NO_DETECTION):
      textmsg(RQ_SCREW_FAIL_WITHOUT_DETECTION_TEXT)
      rq_unhandled_error = RQ_SCREW_FAIL_WITHOUT_DETECTION
      return RQ_SCREW_FAIL_WITHOUT_DETECTION
    else:
      return RQ_SCREW_SUCCESS
    end
  end

  def rq_log_application_warning(screwdriver_faults):

     if(not rq_screwdriver_in_fault(screwdriver_faults)):
      rq_application_warning_message = RQ_NO_FAULT_MESSAGE
      textmsg(RQ_NO_FAULT_MESSAGE)
     end

     if(screwdriver_faults[0] > 0):
       rq_warning_prefix = "Application warnings : "
       rq_fault_separator = ", "
       rq_application_warning = integer_to_binary_list(screwdriver_faults[0])

       if(rq_application_warning[0]):
         rq_application_warning_message = str_cat(rq_warning_prefix, RQ_COMMUNICATION_NOT_READY_MESSAGE)
         textmsg(rq_application_warning_message)
       end
       if(rq_application_warning[1]):
         rq_application_warning_message = str_cat(rq_warning_prefix, RQ_BLOCKED_AT_START_MESSAGE)
         textmsg(rq_application_warning_message)
       end
       if(rq_application_warning[2]):
         rq_application_warning_message = str_cat(rq_warning_prefix, RQ_RESTRICTION_BEFORE_ANGLE_MESSAGE)
         textmsg(rq_application_warning_message)
       end
       if(rq_application_warning[3]):
         rq_application_warning_message = str_cat(rq_warning_prefix, RQ_TIMEOUT_MESSAGE)
         textmsg(rq_application_warning_message)
       end
       if(rq_application_warning[4]):
         rq_application_warning_message = str_cat(rq_warning_prefix, RQ_REGULATION_WHILE_NOT_ACT_MESSAGE)
         textmsg(rq_application_warning_message)
       end
       if(rq_application_warning[5]):
        rq_application_warning_message = str_cat(rq_warning_prefix, RQ_NOT_ACTIVATED_MESSAGE)
        textmsg(rq_application_warning_message)
       end
        if(rq_application_warning[6]):
         rq_application_warning_message = str_cat(rq_warning_prefix, "Over torque")
         textmsg(rq_application_warning_message)
        end
        if(rq_application_warning[7]):
         rq_application_warning_message = str_cat(rq_warning_prefix, "Under torque")
         textmsg(rq_application_warning_message)
        end
        if(rq_application_warning[8]):
         rq_application_warning_message = str_cat(rq_warning_prefix, "Processing recorded data failed")
         textmsg(rq_application_warning_message)
        end
        if(rq_application_warning[9]):
         rq_application_warning_message = str_cat(rq_warning_prefix, "Torque parameters out of bounds")
         textmsg(rq_application_warning_message)
        end
     end
  end

  def rq_screwdriver_in_fault(screwdriver_faults):
    index = 0
    while (index < get_list_length(screwdriver_faults)):
     if(screwdriver_faults[index] > 0):
       return True
     end
     index = index + 1
    end

    return False
  end

  def rq_get_screwdriver_faults_message():
    if(rq_screwdriver_faults[0] == 0):
      return str_cat("Screwdriver faults code : ", to_str(rq_screwdriver_faults))
    end
    rq_application_warning_message = "Application warnings : "
    rq_fault_separator = "<br>"
    rq_application_warning = integer_to_binary_list(rq_screwdriver_faults[0])

    if(rq_application_warning[0]):
         rq_application_warning_message = str_cat(rq_application_warning_message, RQ_COMMUNICATION_NOT_READY_MESSAGE)
    end
    if(rq_application_warning[1]):
      rq_application_warning_message = str_cat(rq_application_warning_message, rq_fault_separator)
      rq_application_warning_message = str_cat(rq_application_warning_message, RQ_BLOCKED_AT_START_MESSAGE)
    end
    if(rq_application_warning[2]):
      rq_application_warning_message = str_cat(rq_application_warning_message, rq_fault_separator)
      rq_application_warning_message = str_cat(rq_application_warning_message, RQ_RESTRICTION_BEFORE_ANGLE_MESSAGE)
    end
    if(rq_application_warning[3]):
      rq_application_warning_message = str_cat(rq_application_warning_message, rq_fault_separator)
      rq_application_warning_message = str_cat(rq_application_warning_message, RQ_TIMEOUT_MESSAGE)
    end
    if(rq_application_warning[4]):
      rq_application_warning_message = str_cat(rq_application_warning_message, rq_fault_separator)
      rq_application_warning_message = str_cat(rq_application_warning_message, RQ_REGULATION_WHILE_NOT_ACT_MESSAGE)
    end
    if(rq_application_warning[5]):
      rq_application_warning_message = str_cat(rq_application_warning_message, rq_fault_separator)
      rq_application_warning_message = str_cat(rq_application_warning_message, RQ_NOT_ACTIVATED_MESSAGE)
    end
    return rq_application_warning_message
  end

  def rq_is_blocked_at_start_cause():
    rq_application_warning = integer_to_binary_list(rq_screwdriver_faults[0])

    return rq_application_warning[1]
  end

  def rq_is_restricted_before_angle_cause():
    rq_application_warning = integer_to_binary_list(rq_screwdriver_faults[0])

    return rq_application_warning[2]
  end

  def rq_is_timeout_cause():
    rq_application_warning = integer_to_binary_list(rq_screwdriver_faults[0])

    return rq_application_warning[3]
  end

  def rq_is_communication_lost_cause():
    return rq_unhandled_error == RQ_SCREW_FAIL_ON_SCREWDRIVER_COMMUNICATION_LOST
  end

  def rq_is_screwdriver_wrong_echo_cause():
    return rq_unhandled_error == RQ_SCREW_FAIL_ON_SCREWDRIVER_NOT_RESPONDING
  end

  def rq_is_contact_not_found_cause():
    return rq_unhandled_error == RQ_SCREW_FAIL_ON_CONTACT_NOT_FOUND
  end

  def rq_is_action_finished_without_detection_cause():
    return rq_unhandled_error == RQ_SCREW_FAIL_WITHOUT_DETECTION
  end

  #--------------------------------------------------------------------------------------------------
  # Turns the screwdriver at the specified speed and torque
  #
  #    regulation_mode        : Regulation mode (default RQ_REGULATION_MODE_SPEED)
  #    torque_Nm              : Torque value in Nm (default 1 Nm)
  #    rotation_angle         : Rotation angle in deg (default 0 deg)
  #    rotation_speed_rpm     : Rotation speed in rpm (default 100 rpm)
  #    direction              : Rotation direction (RQ_DIRECTION_CCW = True, RQ_DIRECTION_CW = False) (default RQ_DIRECTION_CW)
  #    slave_id               : slave id of the screwdriver (default 9)
  #
  #--------------------------------------------------------------------------------------------------
  def rq_screw_turn(regulation_mode=RQ_REGULATION_MODE_SPEED, torque_Nm=1, rotation_angle=0, rotation_speed_rpm=100, direction=RQ_DIRECTION_CW, slave_id=9):
      activation = RQ_ACTIVATE
      operation_mode = RQ_MODE_NORMAL
      regulate = RQ_SCREWDRIVER_ON
      vacuum = rq_get_screw_vacuum_echo(slave_id)
      rotation_current = floor(torque_Nm * 100)
      rotation_speed_raw = floor(rotation_speed_rpm)
      max_supply_current = RQ_MAX_SUPPLY_CURRENT_MA
      time_max = 0
      torque_threshold = 0
      torque_angle_slope = 0

      rq_set_screw_registers_100x(slave_id, regulation_mode, activation, direction, operation_mode, regulate, RQ_TEACHING_OFF, vacuum,
      rotation_current, max_supply_current, rotation_speed_raw, rotation_angle, time_max, torque_threshold, torque_angle_slope)
  end

  #--------------------------------------------------------------------------------------------------
  # Stops the screwdriver
  #
  #    slave_id               : slave id of the screwdriver (default 9)
  #
  #--------------------------------------------------------------------------------------------------
  def rq_screw_stop(slave_id = 9):
      rq_set_screw_regulate(slave_id, False)
  end

  def rq_stop_regulating_and_stop_vacuum(slave_id = 9):
      thread_slave_id = slave_id
      thread stop_vacuum():
        rq_screw_vacuum_off_and_stop_regulate(thread_slave_id)
      end
      run stop_vacuum()
  end
  def rq_update_window_with_next_value(new_value, window):
     i = 0
     while(i < length(window) - 1):
       window[i] = window[i + 1]
       i = i + 1
     end
     window[length(window) - 1] = new_value
     return window
  end
  def rq_average(window):
     sum = 0
     i = 0
     while(i < length(window)):
       sum = sum + window[i]
       i = i + 1
     end
     return sum/length(window)
  end
  def rq_are_all_values_positive(window):
    i = 0
    while(i < length(window)):
      if (window[i] <= 0):
        return 0
      end
      i = i + 1
    end
    return 1
  end

  global rq_z_window = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  global rq_dz_window = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  global rq_z_avg_last = 0
  def rq_compute_next_z_avg(new_z):
    rq_z_window = rq_update_window_with_next_value(new_z, rq_z_window)
    return rq_average(rq_z_window)
  end
  def rq_compute_stop_signal(new_dz):
    rq_dz_window = rq_update_window_with_next_value(new_dz, rq_dz_window)
    return rq_are_all_values_positive(rq_dz_window)
  end

  thread rq_auto_stop():
    counter = 0
    stop_signal = 0
    starting_frame = pose_inv(get_actual_tcp_pose())
    while(get_flag(0)):
      pose = pose_trans(starting_frame, get_actual_tcp_pose())
      z = pose[2]
      z_avg = rq_compute_next_z_avg(z)
      dz = z_avg - rq_z_avg_last
      if (counter > length(rq_z_window)):
        stop_signal = rq_compute_stop_signal(dz)
        if (stop_signal):
          set_flag(0, False)
        end
      end
      rq_z_avg_last = z_avg
      counter = counter + 1
      sleep(0.008)
    end
  end

  def rq_unscrew(direction, force=5, rotation_speed_rpm=100, torque_Nm=4, unscrew_stiffness = [100, 100, 70, 100, 100, 100], unscrew_adaptive_stiffness = True, slave_id=9):
    result = rq_screw_start_force_control_tool_z(force)
    thread_id = result[0]
    force_node_id = result[1]
    rotation_current_mA = floor(torque_Nm * 100)

    node_rpc_server.setforcecontrolstiffness(force_node_id, unscrew_stiffness)
    node_rpc_server.setforcecontroladaptivestiffnessenabledaxes(force_node_id, unscrew_adaptive_stiffness)

    vacuum = rq_get_screw_vacuum_echo(slave_id)

    rq_set_screw_registers_100x(slave_id, RQ_REGULATION_MODE_SPEED, RQ_ACTIVATE, direction, RQ_MODE_NORMAL,
    RQ_SCREWDRIVER_ON, RQ_TEACHING_OFF, vacuum, rotation_current_mA, RQ_MAX_SUPPLY_CURRENT_MA, rotation_speed_rpm,
    0, 0, 0, 0)

    return thread_id
  end

  def rq_wait_for_interruption(slave_id = 9):
    while(get_flag(0) and (rq_get_screw_action(slave_id) == RQ_IN_ACTION)):
      sleep(0.008)
    end
  end

  def rq_unscrew_stop(thread_id, tcp_pose_before_unscrew, slave_id=9):
    vacuum = rq_get_screw_vacuum_echo(slave_id)
    rq_set_screw_registers_100x(slave_id, RQ_REGULATION_MODE_SPEED, RQ_ACTIVATE, RQ_DIRECTION_CW, RQ_MODE_NORMAL,
    RQ_SCREWDRIVER_OFF, RQ_TEACHING_OFF, vacuum, 0, RQ_MAX_SUPPLY_CURRENT_MA, 0, 0, 0, 0, 0)
    rq_screw_stop_force_control(thread_id)
    turns_to_unscrew = rq_get_screw_delta_angle_deg(slave_id)/360
    tcp_pose_after_unscrew = get_actual_tcp_pose()
    distance_to_unscrew = point_dist(tcp_pose_before_unscrew, tcp_pose_after_unscrew) * 1000
    pitch_estimated = distance_to_unscrew/turns_to_unscrew
  end

  def rq_wait_nb_turns(nb_turns=2, slave_id=9):
    time_step_ms = 0.1
    timeout_ms = 2000
    remaining_retries = timeout_ms / time_step_ms
    minimum_nb_degrees = rq_get_screw_delta_angle_deg(slave_id) + nb_turns * 360

    while(rq_get_screw_delta_angle_deg(slave_id) < minimum_nb_degrees and remaining_retries > 0):
      sleep(time_step_ms)
      remaining_retries = remaining_retries - 1
    end
  end

  def rq_auto_unscrew(direction=RQ_DIRECTION_CCW, rotation_speed=100):
    tcp_pose_before_unscrew = get_actual_tcp_pose()
    thread_id = rq_unscrew(direction,rotation_speed_rpm=rotation_speed)
    rq_wait_nb_turns()
    set_flag(0, True)
    auto_stop_thread_id = run rq_auto_stop()
    rq_wait_for_interruption()
    rq_unscrew_stop(thread_id, tcp_pose_before_unscrew)
    join auto_stop_thread_id
  end
  def rq_screw_start_force_control_tool_z(target_force_z = 10):
      return rq_screw_start_force_control(force_control_enabled_axes = [False, False, True, False, False, False], target_force = [0, 0, target_force_z, 0, 0, 0], max_negative_deviation = [0, 0, -0.1, 0, 0, 0], max_positive_deviation = [0, 0, 0.1, 0, 0, 0])
  end
  def rq_screw_start_force_control_tool_z_with_xy_compliance(target_force_z = 10):
      return rq_screw_start_force_control(force_control_enabled_axes = [True, True, True, False, False, False], target_force = [0, 0, target_force_z, 0, 0, 0], max_negative_deviation = [-1, -1, -1, 0, 0, 0], max_positive_deviation = [1, 1, 1, 0, 0, 0])
  end
  def rq_screw_start_scara_mode():
      return rq_screw_start_scara_with_force(target_force_z = 0)
  end
  def rq_screw_start_scara_with_force(target_force_z = 10):
      return rq_screw_start_force_control(force_control_enabled_axes = [True, True, True, False, False, False], target_force = [0, 0, target_force_z, 0, 0, 0], max_negative_deviation = [-0.5, -0.5, -0.5, 0, 0, 0], max_positive_deviation = [0.5, 0.5, 0.5, 0, 0, 0])
  end
  def rq_screw_start_force_control(force_control_enabled_axes = [False, False, False, False, False, False], target_force = [0, 0, 0, 0, 0, 0], max_negative_deviation = [0, 0, 0, 0, 0, 0], max_positive_deviation = [0, 0, 0, 0, 0, 0], stiffness = [100, 100, 100, 100, 100, 100], adaptive_stiffness = True):
      RELATIVE_TO_TCP = 1
      force_node_id = node_rpc_server.createnewforcenode()
      servoj_node_id = node_rpc_server.createnewservojnode()
      node_rpc_server.setparentid(servoj_node_id, force_node_id)
      node_rpc_server.setforcecontrolfeature(force_node_id, RELATIVE_TO_TCP)
      node_rpc_server.setforcecontrolenabledaxes(force_node_id, force_control_enabled_axes)
      node_rpc_server.setforcecontroltargetforce(force_node_id, target_force)
      node_rpc_server.setforcecontrolmaximaldeviation(force_node_id, max_negative_deviation, max_positive_deviation)
      node_rpc_server.setforcecontrolstiffness(force_node_id, stiffness)
      node_rpc_server.setforcecontroladaptivestiffnessenabledaxes(force_node_id, adaptive_stiffness)
      # This moveJ is used to prevent "another thread is already controlling the robot error"
      movej(get_actual_joint_positions())
      set_servoj_node_cmd(get_actual_joint_positions())
      reset_node_executor()
      active_and_reset_node(force_node_id)
      active_and_reset_node(servoj_node_id)
      zero_ftsensor()

      return [run execute_node_thread(), force_node_id]
  end
  def rq_screw_stop_force_control(node_execution_thread):
      kill_thread(node_execution_thread)
  end
  def rq_setup_screw_force(force):
    def concat(str1, str2, str3):
      return str_cat(str1, str_cat(str2, str3))
    end
    def key_val(key, val):
      return concat(concat("`", key, "`"), ":", val)
    end
    def json_force_node(force):
      json = "{"
      json = concat(json, key_val("forceFrame", 1), ",")
      json = concat(json, key_val("isAdaptive", "true"), ",")
      json = concat(json, key_val("isForceControlAboutActualPosition", "true"), ",")
      json = concat(json, key_val("isForceMode", "[false,false,true,false,false,false]"), ",")
      json = concat(json, key_val("maxNegativeDeviation", [0,0,-0.01,0,0,0]), ",")
      json = concat(json, key_val("maxPositiveDeviation", [0,0,0.1,0,0,0]), ",")
      json = concat(json, key_val("stiffness", [0,0,0.8,0,0,0]), ",")
      json = concat(json, key_val("targetTcpWrench", [0,0,force,0,0,0]), "}")
      return json
    end
    def init_force_node(force):
      movej(get_actual_joint_positions()) # This moveJ is used to prevent "another thread is already controlling the robot error".
      force_node_id = node_rpc_server.createnewforcenode()
      node_rpc_server.fromjson(force_node_id, json_force_node(force))
      reset_node_executor()
      active_and_reset_node(force_node_id)
      node_execution_thread = run execute_node_thread()
      return node_execution_thread
    end
    # initialize forcenode: adapt to direction
    node_execution_thread = init_force_node(force)
    return node_execution_thread
  end
  def rq_wait_for_contact_with_thread(max_distance, wanted_speed = 0.004):
    zero_ftsensor()

    return rq_linear_search_urcap(direction="Z+", force_threshold = 10, speed = wanted_speed, max_distance = max_distance, feature = 1)
  end
  def rq_extract_value_from_register_value(register_value, first_bit, total_of_bit):
      register_binary_list = integer_to_binary_list(register_value)
      bit_exponent = 0
      value = 0
      next_bit = first_bit
      last_bit = first_bit + total_of_bit

      while(next_bit < last_bit):
          if(register_binary_list[next_bit]):
              value = value + pow(2,bit_exponent)
          end
          next_bit = next_bit + 1
          bit_exponent = bit_exponent + 1
      end

      return value
  end

  def rq_extract_boolean_from_register_value(register_value, bit_number):
      register_binary_list = integer_to_binary_list(register_value)
      return register_binary_list[bit_number]
  end

  def rq_insert_boolean_in_register_value(register_value, bit_number, boolean_value):
      register_binary_list = integer_to_binary_list(register_value)
      register_binary_list[bit_number] = boolean_value
      return binary_list_to_integer(register_binary_list)
  end

  def rq_insert_lsb_in_register_value(register_value, byte_value):
      return rq_insert_value_in_register_value(register_value, 0, 8, byte_value)
  end

  def rq_insert_msb_in_register_value(register_value, byte_value):
      return rq_insert_value_in_register_value(register_value, 8, 8, byte_value)
  end

  def rq_insert_value_in_register_value(register_value, first_bit, total_of_bit, value):
      register_binary_list = integer_to_binary_list(register_value)
      value_list = integer_to_binary_list(value)
      next_value_bit = 0
      next_register_value_bit = first_bit
      last_bit = first_bit + total_of_bit

      while(next_register_value_bit < last_bit):
          register_binary_list[next_register_value_bit] = value_list[next_value_bit]
          next_register_value_bit = next_register_value_bit + 1
          next_value_bit = next_value_bit + 1
      end

      return binary_list_to_integer(register_binary_list)
  end
  RQ_READ_SCREWDRIVER_REGISTERS_SIZE = 22

  rq_xml_rpc_modbus = rpc_factory("xmlrpc", "http://127.0.0.1:8090/")
  rq_xml_rpc_modbus_debug = rpc_factory("xmlrpc", "http://127.0.0.1:8090/")

  rq_comm_slave_ids = [9]

  global rq_comm_lost = [False, False, False, False]

  rq_comm_write_3_registers_100x_request = [False, False, False, False]
  rq_comm_write_8_registers_100x_request = [False, False, False, False]
  rq_comm_write_register_1000 = [0, 0, 0, 0]
  rq_comm_write_register_1001 = [0, 0, 0, 0]
  rq_comm_write_register_1002 = [0, 0, 0, 0]
  rq_comm_write_register_1003 = [0, 0, 0, 0]
  rq_comm_write_register_1004 = [0, 0, 0, 0]
  rq_comm_write_register_1005 = [0, 0, 0, 0]
  rq_comm_write_register_1006 = [0, 0, 0, 0]
  rq_comm_write_register_1007 = [0, 0, 0, 0]

  rq_comm_write_register_6020_request = [False, False, False, False]
  rq_comm_write_register_6020 = [0, 0, 0, 0]

  rq_comm_read_3_registers_200x_request = [False, False, False, False]
  rq_comm_read_22_registers_200x_request = [False, False, False, False]
  rq_comm_read_register_2000 = [0, 0, 0, 0]
  rq_comm_read_register_2001 = [0, 0, 0, 0]
  rq_comm_read_register_2002 = [0, 0, 0, 0]
  rq_comm_read_register_2003 = [0, 0, 0, 0]
  rq_comm_read_register_2004 = [0, 0, 0, 0]
  rq_comm_read_register_2005 = [0, 0, 0, 0]
  rq_comm_read_register_2006 = [0, 0, 0, 0]
  rq_comm_read_register_2007 = [0, 0, 0, 0]
  rq_comm_read_register_2008 = [0, 0, 0, 0]
  rq_comm_read_register_2009 = [0, 0, 0, 0]
  rq_comm_read_register_2010 = [0, 0, 0, 0]
  rq_comm_read_register_2011 = [0, 0, 0, 0]
  rq_comm_read_register_2012 = [0, 0, 0, 0]
  rq_comm_read_register_2013 = [0, 0, 0, 0]
  rq_comm_read_register_2014 = [0, 0, 0, 0]
  rq_comm_read_register_2015 = [0, 0, 0, 0]
  rq_comm_read_register_2016 = [0, 0, 0, 0]
  rq_comm_read_register_2017 = [0, 0, 0, 0]
  rq_comm_read_register_2018 = [0, 0, 0, 0]
  rq_comm_read_register_2019 = [0, 0, 0, 0]
  rq_comm_read_register_2020 = [0, 0, 0, 0]
  rq_comm_read_register_2021 = [0, 0, 0, 0]

  rq_comm_read_registers_250x_request = [False, False, False, False]
  rq_comm_read_register_2500 = [0, 0, 0, 0]
  rq_comm_read_register_2501 = [0, 0, 0, 0]
  rq_comm_read_register_2502 = [0, 0, 0, 0]
  rq_comm_read_register_2503 = [0, 0, 0, 0]
  rq_comm_read_register_2504 = [0, 0, 0, 0]
  rq_comm_read_register_2505 = [0, 0, 0, 0]
  rq_comm_read_register_2506 = [0, 0, 0, 0]
  rq_comm_read_register_2507 = [0, 0, 0, 0]
  rq_comm_read_register_2508 = [0, 0, 0, 0]

  rq_comm_read_3_registers_602x_request = [False, False, False, False]
  rq_comm_read_register_6020 = [0, 0, 0, 0]
  rq_comm_read_register_6021 = [0, 0, 0, 0]
  rq_comm_read_register_6022 = [0, 0, 0, 0]

  def rq_comm_write_registers_100x(slave_id, registers_100x, number_of_registers):
      if(number_of_registers == 3):
          enter_critical
              index = rq_comm_slave_id_to_index(slave_id)
              rq_comm_write_register_1000[index] = registers_100x[0]
              rq_comm_write_register_1001[index] = registers_100x[1]
              rq_comm_write_register_1002[index] = registers_100x[2]
              rq_comm_write_3_registers_100x_request[index] = True
          exit_critical

          while(rq_comm_write_3_registers_100x_request[index]):
              sleep(0.008)
          end

      elif(number_of_registers == 8):
          enter_critical
              index = rq_comm_slave_id_to_index(slave_id)
              rq_comm_write_register_1000[index] = registers_100x[0]
              rq_comm_write_register_1001[index] = registers_100x[1]
              rq_comm_write_register_1002[index] = registers_100x[2]
              rq_comm_write_register_1003[index] = registers_100x[3]
              rq_comm_write_register_1004[index] = registers_100x[4]
              rq_comm_write_register_1005[index] = registers_100x[5]
              rq_comm_write_register_1006[index] = registers_100x[6]
              rq_comm_write_register_1007[index] = registers_100x[7]
              rq_comm_write_8_registers_100x_request[index] = True
          exit_critical

          while(rq_comm_write_8_registers_100x_request[index]):
              sleep(0.008)
          end

      end
  end

  def rq_comm_write_1_register_6020(slave_id, register_value):
      enter_critical
          index = rq_comm_slave_id_to_index(slave_id)
          rq_comm_write_register_6020[index] = register_value
          rq_comm_write_register_6020_request[index] = True
      exit_critical

      while(rq_comm_write_register_6020_request[index]):
          sleep(0.008)
      end
  end

  def rq_comm_get_registers_100x(slave_id, number_of_registers):
      index = rq_comm_slave_id_to_index(slave_id)

      if(number_of_registers == 3):
          return [rq_comm_write_register_1000[index],
                  rq_comm_write_register_1001[index],
                  rq_comm_write_register_1002[index]]
      elif(number_of_registers == 8):
          return [rq_comm_write_register_1000[index],
                  rq_comm_write_register_1001[index],
                  rq_comm_write_register_1002[index],
                  rq_comm_write_register_1003[index],
                  rq_comm_write_register_1004[index],
                  rq_comm_write_register_1005[index],
                  rq_comm_write_register_1006[index],
                  rq_comm_write_register_1007[index]]
      else:
          popup("Invalid number_of_registers in rq_comm_get_registers_100x(slave_id, number_of_registers)", title="rq_comm_get_registers_100x()", error=True, blocking=True)
      end
  end

  def rq_comm_read_registers_200x(slave_id, number_of_registers):
      if(number_of_registers == 3):
          enter_critical
              index = rq_comm_slave_id_to_index(slave_id)
              rq_comm_read_3_registers_200x_request[index] = True
          exit_critical

          while(rq_comm_read_3_registers_200x_request[index]):
              sleep(0.008)
          end

          return [rq_comm_read_register_2000[index],
                  rq_comm_read_register_2001[index],
                  rq_comm_read_register_2002[index]]

      elif(number_of_registers == RQ_READ_SCREWDRIVER_REGISTERS_SIZE):
          enter_critical
              index = rq_comm_slave_id_to_index(slave_id)
              rq_comm_read_22_registers_200x_request[index] = True
          exit_critical

          while(rq_comm_read_22_registers_200x_request[index]):
              sleep(0.008)
          end

          return [rq_comm_read_register_2000[index],
                  rq_comm_read_register_2001[index],
                  rq_comm_read_register_2002[index],
                  rq_comm_read_register_2003[index],
                  rq_comm_read_register_2004[index],
                  rq_comm_read_register_2005[index],
                  rq_comm_read_register_2006[index],
                  rq_comm_read_register_2007[index],
                  rq_comm_read_register_2008[index],
                  rq_comm_read_register_2009[index],
                  rq_comm_read_register_2010[index],
                  rq_comm_read_register_2011[index],
                  rq_comm_read_register_2012[index],
                  rq_comm_read_register_2013[index],
                  rq_comm_read_register_2014[index],
                  rq_comm_read_register_2015[index],
                  rq_comm_read_register_2016[index],
                  rq_comm_read_register_2017[index],
                  rq_comm_read_register_2018[index],
                  rq_comm_read_register_2019[index],
                  rq_comm_read_register_2020[index],
                  rq_comm_read_register_2021[index]]
      else:
          popup("Invalid number_of_registers in rq_comm_read_registers_200x(slave_id, number_of_registers)", title="rq_comm_read_registers_200x()", error=True, blocking=True)
      end
  end

  def rq_comm_read_registers_250x(slave_id):
      enter_critical
          index = rq_comm_slave_id_to_index(slave_id)
          rq_comm_read_registers_250x_request[index] = True
      exit_critical

      while(rq_comm_read_registers_250x_request[index]):
          sleep(0.008)
      end

      return [rq_comm_read_register_2500[index],
              rq_comm_read_register_2501[index],
              rq_comm_read_register_2502[index],
              rq_comm_read_register_2503[index],
              rq_comm_read_register_2504[index],
              rq_comm_read_register_2505[index],
              rq_comm_read_register_2506[index],
              rq_comm_read_register_2507[index],
              rq_comm_read_register_2508[index]]
  end

  def rq_comm_read_3_registers_6020(slave_id):
      enter_critical
          index = rq_comm_slave_id_to_index(slave_id)
          rq_comm_read_3_registers_602x_request[index] = True
      exit_critical

      while(rq_comm_read_3_registers_602x_request[index]):
          sleep(0.008)
      end

      return [rq_comm_read_register_6020[index],
              rq_comm_read_register_6021[index],
              rq_comm_read_register_6022[index]]
  end

  def rq_comm_slave_id_to_index(slave_id = 9):
      if(slave_id == 9):
          return 0
      else:
          return (slave_id - 1)
      end
  end

  def rq_get_number_of_slaves():
      return get_list_length(rq_comm_slave_ids)
  end

  def rq_read_registers(slave_id, start_address, number_of_registers, client_modbus):
    retries = 10
    index = rq_comm_slave_id_to_index(slave_id)
    while (retries >= 0):
      registers = client_modbus.ModbusServiceWrapper.readRegisters(slave_id, start_address, number_of_registers)

      if(get_list_length(registers) > 0):
        if(registers[0] >= 0):
          rq_comm_lost[index] = False
          break
        else:
          textmsg("An error occurred while reading modbus registers: ", rq_convert_error_number_to_exception(registers[0]))
          rq_comm_lost[index] = True
        end
      else:
        textmsg("An error occurred while reading modbus registers: ", "No registers read")
        rq_comm_lost[index] = True
      end

      retries = retries - 1
    end

    return registers
  end

  def rq_write_registers(slave_id, start_address, registers, client_modbus):
    retries = 10
    success = -1
    index = rq_comm_slave_id_to_index(slave_id)

    while (retries >= 0 and success != 0):
      success = client_modbus.ModbusServiceWrapper.writeRegisters(slave_id, start_address, registers)
      retries = retries - 1
    end
    if(success < 0):
      textmsg("An error occurred while writing modbus registers: ", rq_convert_error_number_to_exception(success))
    end

    rq_comm_lost[index] = (success < 0)

    return success
  end

  thread rq_modbus_comm():
      def rq_handle_write_requests():
          index = 0
          while(index < rq_get_number_of_slaves()):
              if(rq_comm_write_3_registers_100x_request[index]):
                  slave_id = rq_comm_slave_ids[index]
                  rq_write_registers(slave_id, 1000, rq_comm_get_registers_100x(slave_id, 3), rq_xml_rpc_modbus)
                  rq_comm_write_3_registers_100x_request[index] = False
              end
              if(rq_comm_write_8_registers_100x_request[index]):
                  slave_id = rq_comm_slave_ids[index]
                  rq_write_registers(slave_id, 1000, rq_comm_get_registers_100x(slave_id, 8),rq_xml_rpc_modbus)
                  rq_comm_write_8_registers_100x_request[index] = False
              end
              if(rq_comm_write_register_6020_request[index]):
                  slave_id = rq_comm_slave_ids[index]
                  rq_write_registers(slave_id, 6020, [rq_comm_write_register_6020[index]], rq_xml_rpc_modbus)
                  rq_comm_write_register_6020_request[index] = False
              end
              index = index + 1
          end
      end

      def rq_handle_read_requests():
          index = 0
          while(index < rq_get_number_of_slaves()):
              if(rq_comm_read_3_registers_200x_request[index]):
                  slave_id = rq_comm_slave_ids[index]
                  registers_200x = rq_read_registers(slave_id, 2000, 3, rq_xml_rpc_modbus)
                  rq_comm_read_register_2000[index] = registers_200x[0]
                  rq_comm_read_register_2001[index] = registers_200x[1]
                  rq_comm_read_register_2002[index] = registers_200x[2]
                  rq_comm_read_3_registers_200x_request[index] = False
              end
              if(rq_comm_read_22_registers_200x_request[index]):
                  slave_id = rq_comm_slave_ids[index]
                  registers_200x = rq_read_registers(slave_id, 2000, RQ_READ_SCREWDRIVER_REGISTERS_SIZE, rq_xml_rpc_modbus)
                  rq_comm_read_register_2000[index] = registers_200x[0]
                  rq_comm_read_register_2001[index] = registers_200x[1]
                  rq_comm_read_register_2002[index] = registers_200x[2]
                  rq_comm_read_register_2003[index] = registers_200x[3]
                  rq_comm_read_register_2004[index] = registers_200x[4]
                  rq_comm_read_register_2005[index] = registers_200x[5]
                  rq_comm_read_register_2006[index] = registers_200x[6]
                  rq_comm_read_register_2007[index] = registers_200x[7]
                  rq_comm_read_register_2008[index] = registers_200x[8]
                  rq_comm_read_register_2009[index] = registers_200x[9]
                  rq_comm_read_register_2010[index] = registers_200x[10]
                  rq_comm_read_register_2011[index] = registers_200x[11]
                  rq_comm_read_22_registers_200x_request[index] = False
              end
              if(rq_comm_read_registers_250x_request[index]):
                   slave_id = rq_comm_slave_ids[index]
                   registers_250x = rq_read_registers(slave_id, 2500, RQ_READ_SCREWDRIVER_REGISTERS_SIZE, rq_xml_rpc_modbus)
                   rq_comm_read_register_2500[index] = registers_250x[0]
                   rq_comm_read_register_2501[index] = registers_250x[1]
                   rq_comm_read_register_2502[index] = registers_250x[2]
                   rq_comm_read_register_2503[index] = registers_250x[3]
                   rq_comm_read_register_2504[index] = registers_250x[4]
                   rq_comm_read_register_2505[index] = registers_250x[5]
                   rq_comm_read_register_2506[index] = registers_250x[6]
                   rq_comm_read_register_2507[index] = registers_250x[7]
                   rq_comm_read_register_2508[index] = registers_250x[8]
                   rq_comm_read_registers_250x_request[index] = False
              end
              if(rq_comm_read_3_registers_602x_request[index]):
                  slave_id = rq_comm_slave_ids[index]
                  registers_602x = rq_read_registers(slave_id, 6020, 3, rq_xml_rpc_modbus)
                  rq_comm_read_register_6020[index] = registers_602x[0]
                  rq_comm_read_register_6021[index] = registers_602x[1]
                  rq_comm_read_register_6022[index] = registers_602x[2]
                  rq_comm_read_3_registers_602x_request[index] = False
              end
              index = index + 1
          end
      end

      while(True):
          rq_handle_write_requests()
          rq_handle_read_requests()
          sleep(0.032)
      end
  end

  def rq_convert_gripper_id_to_slave_id(gripper_id):
      # Line to support gripper_id in integer and string
      gripper_id_string = str_cat("", gripper_id)

      if (gripper_id_string == "1"):
          return 9
      elif (gripper_id_string == "2"):
          return 2
      elif (gripper_id_string == "3"):
          return 3
      elif (gripper_id_string == "4"):
          return 4
      end
      return 9
  end

  def rq_convert_error_number_to_exception(error_number):
      if(error_number == -1):
          return "INTERRUPTED_ERROR"
      elif(error_number == -2):
          return "TIMEOUT_ERROR"
      elif(error_number == -3):
          return "MODBUS_ERROR"
      elif(error_number == -4):
          return "SERVICE_UNAVAILABLE_ERROR"
      end
  end

  rq_modbus_comm_thread_id = run rq_modbus_comm()
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: Robotiq_Copilot, 2.2.3.37884-alpha, Robotiq Inc.
  #   Type: Machine Tending
  mt_vision_rpc_server = rpc_factory("xmlrpc","http://172.17.101.13:4040")
  def rq_is_stack_light_machine_state_idle():
  return False
  end
  def rq_is_stack_light_machine_state_running():
  return False
  end
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: Robotiq_Copilot, 2.2.3.37884-alpha, Robotiq Inc.
  #   Type: Copilot
  ###############################################################
  # Script file used to communicate with Robotiq's ft sensor
  # Version: 0.0.1
  ###############################################################

  node_rpc_server = rpc_factory("xmlrpc","http://127.0.0.1:4251/node")
  linalg = rpc_factory("xmlrpc","http://127.0.0.1:4251/linalg")
  storevar = rpc_factory("xmlrpc","http://127.0.0.1:4251/storevariable")
  kinematics_rpc_server = rpc_factory("xmlrpc","http://127.0.0.1:4251/")

  global Fx = 0.0
  global Fy = 0.0
  global Fz = 0.0
  global Mx = 0.0
  global My = 0.0
  global Mz = 0.0
  global T_base_sensor = p[0,0,0,0,0,0]
  global tcp_wrench = [0,0,0,0,0,0]
  global base_wrench = [0,0,0,0,0,0]
  global sensor_wrench = [0,0,0,0,0,0]
  global rq_depal_end_pose_offset = p[0,0,0,0,0,0]
  global rq_ft_sensor_connected = False

  rq_target_joint_positions = get_actual_joint_positions()
  rq_elapsed_time = 0
  rq_force_protect_urcap = 0.0
  rq_torque_protect_urcap = 0.0
  rq_collision_detection_enabled = False
  rq_collision_detection_active_time = 0.0
  rq_halt_on_collision_detection = True
  is_rq_prevent_steady_enabled = True
  rq_active_node = 0
  rq_node_executor_thread_running = False
  rq_lookahead_time = 0.05
  rq_continue_node_execution = True
  rq_controller_time_step = 0.008

  rq_linear_axis_move_abs_target_position = 0.0
  rq_linear_axis_move_abs_target_speed = 0.0
  rq_linear_axis_move_abs_target_acc = 0.0
  rq_linear_axis_move_abs_target_decel = 0.0
  rq_linear_axis_move_absolute_thread = 0
  rq_linear_axis_move_absolute_thread_running = False

  def pose_to_list(p):
    return [p[0], p[1], p[2], p[3], p[4], p[5]]
  end

  def list_to_pose(l):
    return p[l[0], l[1], l[2], l[3], l[4], l[5]]
  end

  def rq_init_path(pathId):
     initPathAnswer = node_rpc_server.initpath(pathId)
     verify_path_answer(initPathAnswer)
     return initPathAnswer[0]
  end

  def concat(str1, str2, str3):
    return str_cat(str1, str_cat(str2, str3))
  end
  def key_val(key, val):
    return concat(concat("`", key, "`"), ":", val)
  end

  thread rq_prevent_steady():
    local q_start = get_target_joint_positions()
    local q = q_start
    local p = 0

    while True:
      p = p + rq_controller_time_step*4*3.14159
      local offset = 0.000001*sin(p)
      q[5] = q_start[5] + offset
      servoj(q)
    end
  end

  def linear_axis_move_abs(target_position,
                           target_speed,
                           target_acceleration,
                           target_deceleration,
                           is_blocking,
                           prevent_steady = True):
    rq_linear_axis_move_abs_target_position = target_position
    rq_linear_axis_move_abs_target_speed = target_speed
    rq_linear_axis_move_abs_target_acc = target_acceleration
    rq_linear_axis_move_abs_target_decel = target_deceleration
    is_rq_prevent_steady_enabled = prevent_steady

    if( rq_linear_axis_move_absolute_thread_running ):
      kill rq_linear_axis_move_absolute_thread
    end
    rq_linear_axis_move_absolute_thread = run linear_axis_move_abs_thread()
    if(is_blocking):
      join rq_linear_axis_move_absolute_thread
    end
  end #linear_axis_move_abs

  thread linear_axis_move_abs_thread():

    if is_rq_prevent_steady_enabled:
      rq_prevent_steady_thread = run rq_prevent_steady()
    end

    rq_linear_axis_move_absolute_thread_running = True
    timeout_in_milliseconds = 500
    target_position_reached = False
    number_of_done_status_received_while_not_at_target = 0

    while( not target_position_reached ):
      move_absolute_response = node_rpc_server.linearaxismove(rq_linear_axis_move_abs_target_position,
                                                              rq_linear_axis_move_abs_target_speed,
                                                              rq_linear_axis_move_abs_target_acc,
                                                              rq_linear_axis_move_abs_target_decel,
                                                              timeout_in_milliseconds)

      if move_absolute_response == 0: # Done
        position_tolerance = 1e-3
        local position = node_rpc_server.linearaxisgetactualposition() # local because it is a variable under 15 chars that a user could have defined
        target_position_reached = ( norm( position - rq_linear_axis_move_abs_target_position ) < position_tolerance )
        if not target_position_reached:
          number_of_done_status_received_while_not_at_target = number_of_done_status_received_while_not_at_target + 1
          if ( number_of_done_status_received_while_not_at_target > 10 ): #When the move starts, it may take some time before the status changes from done to busy so we accept a certain number of done status without being at the target position
            textmsg("error: target position should be reached when move absolute status is Done")
          end
        end
      elif move_absolute_response == 1: # Normal (safeguard stopped, busy moving, or paused)
        # do nothing
      elif move_absolute_response == 2: # Error
        textmsg("Linear axis absolute move error")
        popup("Program paused because axis is not ready or the requested position is outside the allowed range.",
              title="Linear axis move error", warning=False, error=True, blocking=True)
        socket_send_line("pause", "RQDashboardClient") # If the axis is not ready, this allows the user to go fix it and then resume the program.
        sleep(1.0) # The socket_send_line command is non-blocking, so we need to wait for the progam to pause.
                   # Without the sleep, execution will continue and multiple popups and program pauses will be executed.
      end

      sleep(rq_controller_time_step)
    end #while
    rq_linear_axis_move_absolute_thread_running = False

    if is_rq_prevent_steady_enabled:
      kill rq_prevent_steady_thread
    end

  end # linear_axis_move_abs_thread

  def setup_force_node_on_server(generic_rq_insertion_force_node_id = 1,
                                 feature=1,
                                 targetforce = [0,0,0,0,0,0],
                                 force_control_enabled_axes = [False, False, False, False, False, False],
                                 max_negative_deviation_vector = [-0.1, -0.1, -0.1, -0.1, -0.1, -0.1],
                                 max_positive_deviation_vector = [0.1, 0.1, 0.1, 0.1, 0.1, 0.1],
                                 adaptiveStiffness = True):
    node_rpc_server.setforcecontrolfeature(generic_rq_insertion_force_node_id, feature)
    node_rpc_server.setforcecontroltargetforce(generic_rq_insertion_force_node_id, targetforce)
    node_rpc_server.setforcecontrolenabledaxes(generic_rq_insertion_force_node_id, force_control_enabled_axes)
    node_rpc_server.setforcecontrolmaximaldeviation(generic_rq_insertion_force_node_id, max_negative_deviation_vector, max_positive_deviation_vector)
    node_rpc_server.setforcecontroladaptivestiffnessenabledaxes(generic_rq_insertion_force_node_id, True)
  end

  def verify_path_answer(path_answer):
   initPathStatusCode = path_answer[1]
   handle_path_node_error_code(initPathStatusCode)
  end

  def handle_path_node_error_code(initPathStatusCode):
    if initPathStatusCode == -1:
      popup("Could not compute path with the selected options.", "Robotiq's FT Sensor", blocking=True, error=True)
    elif initPathStatusCode == 1:
      popup("Joint solution impossible. Change your starting position.", "Robotiq's FT Sensor", blocking=True, error=True)
    elif initPathStatusCode == 2:
      popup("Discontinuous path detected. Change your starting position.", "Robotiq's FT Sensor", blocking=True, error=True)
    elif initPathStatusCode == 3:
      popup("Path time limit has been reached. Increase the speed of your path or break it down in multiple shorter paths.", "Robotiq's FT Sensor", blocking=True, error=True)
    elif initPathStatusCode == 4:
      popup("Could not compute path with the selected options. Computing path timeout.", "Robotiq's FT Sensor", blocking=True, error=True)
    elif initPathStatusCode == 5:
      popup("Path computation was aborted.", "Robotiq's FT Sensor", blocking=True, error=True)
    elif initPathStatusCode == 6:
      popup("A previous path computation is still in progress. Please try again in a few seconds.", "Robotiq's FT Sensor", blocking=True, error=True)
    elif initPathStatusCode == 7:
      textmsg("Path initialization error: Invalid path id.") # No popup needed in this case.
    elif initPathStatusCode == 8:
      popup("Palletizer error: box number out of range.", blocking=True, error=True)
    elif initPathStatusCode == 9:
      popup("Palletizer error: collision detected.", blocking=True, error=True)
    elif initPathStatusCode == 10:
      popup("Palletizer error: boxes overlap in layer.", blocking=True, error=True)
    elif initPathStatusCode == 11:
      popup("Palletizer error: empty layer.", blocking=True, error=True)
    elif initPathStatusCode == 12:
      popup("Palletizer error: The PLC was not connected during node creation.", blocking=True, error=True)
    elif initPathStatusCode != 0:
      textmsg("Unexpected initPathStatusCode value : ", initPathStatusCode)
    end

    if initPathStatusCode != 0:
      halt
    end
  end


  def rq_wait_ft_sensor_steady(timeout = 2000):

    max_mean_squared_error = [0.1, 0.1, 0.1, 0.0001, 0.0001, 0.0001]
    local mean = sensor_wrench

    mean_squared_error = sensor_wrench
    local i = 0
    while i<6:
      mean_squared_error[i] = mean_squared_error[i] * mean_squared_error[i]
      i=i+1
    end

    is_sensor_steady = False
    local alpha = 0.9
    local timer = 0

    while (not is_sensor_steady) and (timer < timeout):
      sleep(rq_controller_time_step)
      timer = timer + 8

      i = 0
      while i < 6:
        mean[i] = alpha * mean[i] + (1.0 - alpha) * sensor_wrench[i]
        error = sensor_wrench[i] - mean[i]
        mean_squared_error[i] = alpha * mean_squared_error[i] + ((1.0 - alpha) * error * error)
        i = i+1
      end

      is_sensor_steady = True
      i = 0
      while (i < 6) and is_sensor_steady:
        is_sensor_steady = mean_squared_error[i] < max_mean_squared_error[i]
        i = i+1
      end
    end

    return is_sensor_steady
  end

  thread rq_elapsed_timer_ms():
    rq_elapsed_time = 0
  dt = 1000/500
    while True:
      rq_elapsed_time =  rq_elapsed_time + dt
      sync()
    end
  end

  def get_sensor_fx():
    return Fx
  end

  def get_sensor_fy():
    return Fy
  end

  def get_sensor_fz():
    return Fz
  end

  def get_sensor_mx():
    return Mx
  end

  def get_sensor_my():
    return My
  end

  def get_sensor_mz():
    return Mz
  end

  def get_applied_tcp_force(index):
    return -1.0 * tcp_wrench[index]
  end

  def get_applied_base_force(index):
    return -1.0 * base_wrench[index]
  end

  def express_vector_in_new_frame(T_from_to, V_from):
    Q_from_to = p[0, 0, 0, T_from_to[3], T_from_to[4], T_from_to[5]]
    V_to = pose_trans(pose_inv(Q_from_to), p[V_from[0], V_from[1], V_from[2], 0, 0, 0])
    return [V_to[0], V_to[1], V_to[2]]
  end

  def express_force_in_frame(T_from_to, wrench_from):
    F = express_vector_in_new_frame(T_from_to, [wrench_from[0], wrench_from[1], wrench_from[2]])
    T = express_vector_in_new_frame(T_from_to, [wrench_from[3], wrench_from[4], wrench_from[5]])
    return [F[0], F[1], F[2], T[0], T[1], T[2]]
  end

  def express_pose_A_relative_to_pose_B(pose_A, pose_B):
    return pose_trans(pose_inv(pose_B), pose_A)
  end

  thread read_force():


    if (not socket_open("127.0.0.1", 29999, "RQDashboardClient")):
      popup("Can't connect to the Dashboard server", "Robotiq's FT Sensor", error=True)
      halt
    end

    rq_collision_detection_active_count = 0
    rq_collision_detection_active = False

    while True:

        T_base_tcp = get_actual_tcp_pose()
        T_base_flange = get_actual_tool_flange_pose()
        T_flange_sensor = p[0, 0, 0, 0, 0, 0]
        T_base_sensor = pose_trans(T_base_flange, T_flange_sensor)

        T_flange_tcp = pose_trans( pose_inv(T_base_flange), T_base_tcp)
        T_sensor_tcp = pose_trans( pose_inv(T_flange_sensor), T_flange_tcp)

        sensor_wrench = express_force_in_frame(T_base_sensor, get_tcp_force())
        tcp_wrench = wrench_trans(pose_inv(T_sensor_tcp), sensor_wrench)
        base_wrench = express_force_in_frame(pose_inv(T_base_tcp), tcp_wrench)

        Fx = sensor_wrench[0]
        Fy = sensor_wrench[1]
        Fz = sensor_wrench[2]
        Mx = sensor_wrench[3]
        My = sensor_wrench[4]
        Mz = sensor_wrench[5]

        write_output_float_register(TCP_FX_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[0])
        write_output_float_register(TCP_FY_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[1])
        write_output_float_register(TCP_FZ_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[2])
        write_output_float_register(TCP_MX_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[3])
        write_output_float_register(TCP_MY_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[4])
        write_output_float_register(TCP_MZ_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[5])

        if rq_collision_detection_enabled:
            if rq_collision_detection_active_time < (0.5*rq_controller_time_step):
                if norm([Fx, Fy, Fz]) > rq_force_protect_urcap:
                    rq_on_collision_detection("Force limit value exceeded.")
                elif norm([Mx, My, Mz]) > rq_torque_protect_urcap:
                    rq_on_collision_detection("Torque limit value exceeded.")
                end
            else:
                rq_collision_detection_active_time = rq_collision_detection_active_time + rq_controller_time_step
                if rq_collision_detection_active_time >= 1.0:
                    rq_collision_detection_active_time = 0.0
                end
            end
        end

        sync()
        sync()
        sync()
        sync()

    end
  end

  def rq_get_ft_sensor_state():
    socket_open("127.0.0.1",63350,"rq_ft_sensor_state")
    socket_send_string("CURRENT STATE", "rq_ft_sensor_state")
    rq_sensor_state = socket_read_string("rq_ft_sensor_state")
    socket_close("rq_ft_sensor_state")

    if rq_sensor_state == "":
      rq_sensor_state = "RQ_STATE_INIT"
    end

    return rq_sensor_state
  end

  def rq_ft_sensor_disconnected_warn_user():
    socket_open("127.0.0.1",29999,"SensorWarning")
    socket_send_string("popup FT Sensor must be connected to run this program.","SensorWarning")
    socket_send_byte(10,"SensorWarning")
    socket_close("SensorWarning")
  end

  def rq_ft_sensor_disconnected_stop_program():
    socket_open("127.0.0.1", 30002, "rq_ft_sensor_stop_socket")

    socket_send_string("def rq_ft_sensor_stop_program():", "rq_ft_sensor_stop_socket")
    socket_send_byte(10, "rq_ft_sensor_stop_socket")
    socket_send_string("  stopj(5.0)", "rq_ft_sensor_stop_socket")
    socket_send_byte(10, "rq_ft_sensor_stop_socket")
    socket_send_string("end", "rq_ft_sensor_stop_socket")
    socket_send_byte(10, "rq_ft_sensor_stop_socket")

    socket_close("rq_ft_sensor_stop_socket")
  end

  def rq_ft_sensor_disconnected_check():
    if rq_get_ft_sensor_state() == "RQ_STATE_INIT":
      rq_ft_sensor_disconnected_stop_program()
      rq_ft_sensor_disconnected_warn_user()

      return True
    else:
      return False
    end
  end

  #RTDE input registers
  TARGET_JOINT_0_INPUT_REGISTER_DOUBLE = 40
  TARGET_JOINT_1_INPUT_REGISTER_DOUBLE = 41
  TARGET_JOINT_2_INPUT_REGISTER_DOUBLE = 42
  TARGET_JOINT_3_INPUT_REGISTER_DOUBLE = 43
  TARGET_JOINT_4_INPUT_REGISTER_DOUBLE = 44
  TARGET_JOINT_5_INPUT_REGISTER_DOUBLE = 45
  FINISH_NODE_INPUT_REGISTER_INT32 = 40
  RUNTIME_ERROR_INPUT_REGISTER_INT32 = 41
  ACTIVATION_NODE_COUNT_INPUT_REGISTER_INT32 = 42

  #RTDE output registers
  ACTIVE_NODE_OUTPUT_REGISTER_INT32 = 40
  NODE_EXECUTION_OUTPUT_COUNT_INT32 = 41
  ACTIVATION_NODE_COUNT_OUTPUT_REGISTER_INT32 = 42
  TCP_FX_ACTUAL_OUTPUT_DOUBLE = 34
  TCP_FY_ACTUAL_OUTPUT_DOUBLE = 35
  TCP_FZ_ACTUAL_OUTPUT_DOUBLE = 36
  TCP_MX_ACTUAL_OUTPUT_DOUBLE = 37
  TCP_MY_ACTUAL_OUTPUT_DOUBLE = 38
  TCP_MZ_ACTUAL_OUTPUT_DOUBLE = 39
  GENERAL_OUTPUT_DOUBLE_40 = 40
  GENERAL_OUTPUT_DOUBLE_41 = 41
  GENERAL_OUTPUT_DOUBLE_42 = 42
  GENERAL_OUTPUT_DOUBLE_43 = 43
  GENERAL_OUTPUT_DOUBLE_44 = 44
  GENERAL_OUTPUT_DOUBLE_45 = 45

  write_output_integer_register(ACTIVE_NODE_OUTPUT_REGISTER_INT32, 0)
  write_output_integer_register(NODE_EXECUTION_OUTPUT_COUNT_INT32, 0)
  write_output_integer_register(ACTIVATION_NODE_COUNT_OUTPUT_REGISTER_INT32, 0)
  write_output_float_register(TCP_FX_ACTUAL_OUTPUT_DOUBLE, 0)
  write_output_float_register(TCP_FY_ACTUAL_OUTPUT_DOUBLE, 0)
  write_output_float_register(TCP_FZ_ACTUAL_OUTPUT_DOUBLE, 0)
  write_output_float_register(TCP_MX_ACTUAL_OUTPUT_DOUBLE, 0)
  write_output_float_register(TCP_MY_ACTUAL_OUTPUT_DOUBLE, 0)
  write_output_float_register(TCP_MZ_ACTUAL_OUTPUT_DOUBLE, 0)

  global activation_node_count = 0
  global node_execution_count = 0

  def element_wise_subtract(l1, l2):
    local r = l1
    local i = 0
    while i<length(r):
      r[i]=l1[i]-l2[i]
      i=i+1
    end
    return r
  end

  def element_wise_add(l1, l2):
    local result = l1
    local i = 0
    while i < length(result):
      result[i] = l1[i] + l2[i]
      i = i + 1
    end
    return result
  end

  def list_by_scalar_multiply(l1, scalar):
      local r = l1
      local i = 0
      while i<length(r):
        r[i]=l1[i]*scalar
        i=i+1
      end
      return r
   end

  def norm_inf(v):
    local norm = 0
    local i = 0
    while i<length(v):
        n = norm(v[i])
        if(n > norm):
          norm = n
        end
      i=i+1
    end
    return norm
  end

  def active_and_reset_node(nodeId):
    server_activation_node_count = read_input_integer_register(ACTIVATION_NODE_COUNT_INPUT_REGISTER_INT32)

    activation_node_count = activation_node_count + 1
    node_execution_count = 0
    write_output_integer_register(NODE_EXECUTION_OUTPUT_COUNT_INT32, node_execution_count)
    rq_active_node = nodeId
    write_output_integer_register(ACTIVE_NODE_OUTPUT_REGISTER_INT32, nodeId)
    write_output_integer_register(ACTIVATION_NODE_COUNT_OUTPUT_REGISTER_INT32, activation_node_count)

    while server_activation_node_count == read_input_integer_register(ACTIVATION_NODE_COUNT_INPUT_REGISTER_INT32):
      sleep(rq_controller_time_step)
    end
  end

  def execute_node(nodeId, startThread = False):
    node_execution_thread = 0
    active_and_reset_node(nodeId)
    if startThread:
      rq_target_joint_positions = get_actual_joint_positions()
      movej(rq_target_joint_positions) # This movej is used to prevent the "another thread is already controlling the robot" error.
      rq_continue_node_execution = True
      node_execution_thread = run execute_node_thread()
    end
    while not active_node_completed():
      sync()
    end
    return node_execution_thread
  end

  def setup_node_execution_related_variables():
    activation_node_count = 0
    node_execution_count = 0
    write_output_integer_register(ACTIVE_NODE_OUTPUT_REGISTER_INT32, 0)
    write_output_integer_register(ACTIVATION_NODE_COUNT_OUTPUT_REGISTER_INT32, activation_node_count)
    write_output_integer_register(NODE_EXECUTION_OUTPUT_COUNT_INT32, node_execution_count)
    sleep(rq_controller_time_step)
  end

  def start_node_executor():
    setup_node_execution_related_variables()

    succeeded = node_rpc_server.startnodeexecutor()
    if not succeeded:
      node_rpc_server.stopnodeexecutor()
      sleep(0.5) # Needed for URControl to free the input registers.
      succeeded = node_rpc_server.startnodeexecutor()
      if not succeeded:
        popup("RTDE interface cannot initialize. Make sure that Ethernet/IP adapter and Profinet are disabled, and that no other URCaps use the RTDE interface.", "Robotiq Copilot", error=True)
        halt
      end
    end

    hand_shake_xmlrpcserver()
  end

  def reset_node_executor():
    setup_node_execution_related_variables()

    succeeded = node_rpc_server.resetnodeexecutor()
    if not succeeded:
      popup("RTDE interface cannot initialize. Make sure that Ethernet/IP adapter and Profinet are disabled, and that no other URCaps use the RTDE interface.", "Robotiq Copilot", error=True)
      halt
    end

    hand_shake_xmlrpcserver()
  end

  def hand_shake_xmlrpcserver():
    timer_thread = run rq_elapsed_timer_ms()
    sleep(rq_controller_time_step)
    node_execution_initialized = False
    while (not node_execution_initialized) and (rq_elapsed_time < 100):
      node_execution_initialized = (read_input_integer_register(FINISH_NODE_INPUT_REGISTER_INT32) == -1)
      sleep(rq_controller_time_step)
    end
    kill timer_thread

    if (not node_execution_initialized):
      popup("Node Execution initialization failed.", "Robotiq Copilot", error=True)
      halt
    end
  end

  thread execute_node_thread():
    rq_target_joint_positions = get_actual_joint_positions()
    servoj(rq_target_joint_positions)
    while rq_continue_node_execution:
      new_rq_target_joint_positions = update_target_position()
      joint_target_distances = element_wise_subtract(new_rq_target_joint_positions, rq_target_joint_positions)
      max_joint_target_displacement = norm_inf(joint_target_distances)
      if max_joint_target_displacement > 0.2:
          textmsg("previous target position: ", rq_target_joint_positions)
          textmsg("next target position: ", new_rq_target_joint_positions)
          textmsg("max joint target displacement: ", max_joint_target_displacement)
          popup("Node executor error: see Log tab for details", "Robotiq Copilot", False, True, True)
          halt
      end

      local i = 1
      while i < 5: # (servoj frequency)/(rtde frequency) = 500/125 = 4
        rq_target_joint_positions_interpolated = element_wise_add( rq_target_joint_positions,
                                                                   list_by_scalar_multiply(joint_target_distances, 0.25*i) )
        servoj(rq_target_joint_positions_interpolated, t=get_steptime(), lookahead_time=rq_lookahead_time, gain=500)
        i = i + 1
      end

      rq_target_joint_positions = new_rq_target_joint_positions
    end
    stopj(5)
  end

  # The thread below is used to prevent "another thread is already controlling the robot error".
  # In some occasions, even a sleep(0.05) will not work so this is necessary (until fixed by UR).
  # The thread is immediately killed to avoid unnecessary motion for the case of a parent node
  # that modifies the servoj target joint positions.
  def kill_thread( thread_id ):
    kill thread_id
    run_movej_thread = run movej_thread()
    sleep(rq_controller_time_step)
    kill run_movej_thread
  end

  thread movej_thread():
    movej(rq_target_joint_positions)
  end

  def active_node_completed():
    return (read_input_integer_register(ACTIVATION_NODE_COUNT_INPUT_REGISTER_INT32) == activation_node_count) and
           (read_input_integer_register(FINISH_NODE_INPUT_REGISTER_INT32) == rq_active_node)
  end

  def rq_handle_error_code(code):
    message = "Runtime error!"

    if code == 1:
      message = "Robotiq license error!"
    elif code == 2:
      message = "Program stopped due to runtime error. Please restart the program."
    end

    popup(message, "Robotiq Copilot", error=True)
    halt
  end

  def update_target_position():

    error_code = read_input_integer_register(RUNTIME_ERROR_INPUT_REGISTER_INT32)

    if error_code != 0:
      rq_handle_error_code(error_code)
    end

    new_rq_target_joint_positions = [0,0,0,0,0,0]
    new_rq_target_joint_positions[0] = read_input_float_register(TARGET_JOINT_0_INPUT_REGISTER_DOUBLE)
    new_rq_target_joint_positions[1] = read_input_float_register(TARGET_JOINT_1_INPUT_REGISTER_DOUBLE)
    new_rq_target_joint_positions[2] = read_input_float_register(TARGET_JOINT_2_INPUT_REGISTER_DOUBLE)
    new_rq_target_joint_positions[3] = read_input_float_register(TARGET_JOINT_3_INPUT_REGISTER_DOUBLE)
    new_rq_target_joint_positions[4] = read_input_float_register(TARGET_JOINT_4_INPUT_REGISTER_DOUBLE)
    new_rq_target_joint_positions[5] = read_input_float_register(TARGET_JOINT_5_INPUT_REGISTER_DOUBLE)

    node_execution_count = node_execution_count + 1
    write_output_integer_register(NODE_EXECUTION_OUTPUT_COUNT_INT32, node_execution_count)
    return new_rq_target_joint_positions
  end

  def set_servoj_node_cmd(q):
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_40, q[0])
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_41, q[1])
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_42, q[2])
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_43, q[3])
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_44, q[4])
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_45, q[5])
  end

  def rq_collision_detection_start(force_limit = 140, torque_limit = 14, halt_on_collision = True):
    rq_force_protect_urcap = force_limit
    rq_torque_protect_urcap = torque_limit
    rq_collision_detection_active_time = 0.0
    rq_collision_detection_enabled = True
    rq_halt_on_collision_detection = halt_on_collision
  end

  def rq_collision_detection_stop():
    rq_collision_detection_enabled = False
  end

  def rq_on_collision_detection(message):
    textmsg("Collision Detection. " + message)
    popupTitle = "Collision Detection"
    if rq_halt_on_collision_detection:
      popup(message + " Program halt.", popupTitle, False, True, False)
      halt
    else:
      popup(message + " Program suspend.", popupTitle, True, False, False)
      socket_send_line("pause", "RQDashboardClient")
      rq_collision_detection_active_time = rq_controller_time_step
    end
  end

  def round(number_to_round):
    if number_to_round - floor(number_to_round) < 0.5:
      return floor(number_to_round)
    else:
      return ceil(number_to_round)
    end
  end

  def rq_execute_box_trajectory(nodeId, current_box_count, has_box_payload, end_pose_offset = p[0,0,0,0,0,0]):
    rq_lookahead_time = 0.08
    local payload_mass = get_target_payload()
    local payload_cog  = get_target_payload_cog()
    local flange_payload = [payload_mass, payload_cog[0], payload_cog[1], payload_cog[2]]

    path_answer = node_rpc_server.initboxtrajectory(nodeId, current_box_count, has_box_payload, flange_payload, end_pose_offset)

    verify_path_answer(path_answer)
    reset_node_executor()
    node_execution_thread = execute_node(nodeId, True)
    rq_continue_node_execution = False
    join node_execution_thread
    rq_lookahead_time = 0.05
  end

  ################################
  # MAIN
  ################################

  run read_force()
  start_node_executor()

  preparationErrorXmlRpcClient = rpc_factory("xmlrpc","http://localhost:35647")
  contactOffsetXmlRpcClient = rpc_factory("xmlrpc","http://localhost:41115")
  palletizerXmlRpcClient = rpc_factory("xmlrpc","http://localhost:43775")
  machineTendingXmlRpcClient = rpc_factory("xmlrpc","http://localhost:42733")
    ###############################################################
    # Halt if a script preparation error occurred
    ###############################################################
    def checkForScriptPreparationException():
      if(preparationErrorXmlRpcClient.hasErrorOccurred()):
        popup(preparationErrorXmlRpcClient.getErrorMessage(), title=preparationErrorXmlRpcClient.getNodeInErrorTitle(), error=True, blocking=True)
        halt
      end
    end

    checkForScriptPreparationException()
  #***********************************************************************************************
  # verify tap detection
  #***********************************************************************************************

  def rq_tap_count(forces, high_threshold):

    low_threshold = 2
    tapCount = 0
    lookingForPeak = True
    indexDown = 0

    i = 1
    lastIndex = length(forces) - 1
    while i <= lastIndex:

      deltaForce = forces[i] - forces[0]

     if lookingForPeak:
        if deltaForce >  high_threshold:
          lookingForPeak = False
        end
      else:
        if deltaForce < low_threshold:
          tapCount = tapCount + 1
          lookingForPeak = True
          indexDown = i
        end
      end
      i = i + 1

    end

    if indexDown != lastIndex:
      tapCount = 0
    end

    return tapCount

  end
  def shift_right(list, default_value = 0):

     i = length(list)-1
     while (i > 0):
        list[i]=list[i-1]
        i=i-1
     end
     list[0] = default_value

     return list
  end

  #***********************************************************************************************
  # Wait for force reached
  #***********************************************************************************************
  # desired_wrench : desired wrench
  # is_active      : list of 0 and 1, 1 : axis is controlled
  # feature        : 0:base, 1:tcp
  # timeout        : timeout in miliseconds
  #***********************************************************************************************
  def rq_wait_for_force_reached(desired_wrench, is_active, feature, timeout):

    feature_base = 0
    feature_tool = 1
    time_constant = 0.025
    alpha = 1 - pow(2.718, -1.0 * rq_controller_time_step / time_constant)

    thresholds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    minimal_thresholds = [1.0, 1.0, 1.0, 0.1, 0.1, 0.1]

    applied_wrench = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    filtered_wrench = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]

    if (feature == feature_base):
      applied_wrench = list_by_scalar_multiply(base_wrench, -1.0)
    else:
      applied_wrench = list_by_scalar_multiply(tcp_wrench, -1.0)
    end
    filtered_wrench = applied_wrench

    i = 0
    while (i < 6):
      if (is_active[i]):
        thresholds[i] = 0.05 * norm(desired_wrench[i])
        if thresholds[i] < minimal_thresholds[i]:
          thresholds[i] = minimal_thresholds[i]
        end
      else:
        thresholds[i] = 10000
      end
      i = i+1
    end

   force_reached = False

   timer = 0

   while ((not force_reached) and (timer < timeout)):

      if (feature == feature_base):
         applied_wrench = list_by_scalar_multiply(base_wrench, -1.0)
      else:
         applied_wrench = list_by_scalar_multiply(tcp_wrench, -1.0)
      end

      i = 0
      while (i < 6):
        filtered_wrench[i] = (alpha * applied_wrench[i]) + ((1.0 - alpha) * filtered_wrench[i])
        i = i+1
      end

      force_reached = True

      i = 0
      while ((i < 6) and force_reached):
        error = norm(desired_wrench[i] - filtered_wrench[i])
        if (error > thresholds[i]):
          force_reached = False
        end
        i = i + 1
      end

      timer = timer + rq_controller_time_step

      sleep(rq_controller_time_step)

    end

    return force_reached
  end
  #***********************************************************************************************
  # verify click detection
  #***********************************************************************************************
  click_detection_children_ended = False

  def rq_click_detection(force_drop_threshold = 10, torque_drop_threshold = 1, force_radio_button_selected = True):

    current_norm = 0
    drop_threshold = 0
    norms = [0.0, 0.0, 0.0, 0.0, 0.0]
    click_detected = False
    wrench_indices = [0,0,0]

    if(force_radio_button_selected):
      drop_threshold = force_drop_threshold
      wrench_indices = [0,1,2]
    else:
      drop_threshold =torque_drop_threshold
      wrench_indices = [3,4,5]
    end

    while ((not click_detection_children_ended) and (not click_detected)):

      current_norm = norm([sensor_wrench[wrench_indices[0]], sensor_wrench[wrench_indices[1]], sensor_wrench[wrench_indices[2]]])

      norms[4] = norms[3]
      norms[3] = norms[2]
      norms[2] = norms[1]
      norms[1] = norms[0]
      norms[0] = current_norm

      avg_norm = (norms[2] + norms[3] + norms[4]) / 3.0

      #Check if clicking is detected with force
      norm_drop = avg_norm - current_norm
      if(norm_drop > drop_threshold):
        textmsg("Click detected")
        click_detected=True
      else:
        sleep(rq_controller_time_step)
      end
    end

    return click_detected
  end
  ###############################################################
  # Script file used to define Robotiq functions for the Insertion node
  # Version: 0.0.2
  ###############################################################

  rq_ins_offset = p[0, 0, 0, 0, 0, 0]
  rq_ins_start_pose = p[0, 0, 0, 0, 0, 0]
  rq_actual_to_destination = p[0, 0, 0, 0, 0, 0]
  rq_ins_destination =p[0, 0, 0, 0, 0, 0]
  rq_ins_speed_setting = 0
  rq_rotation_not_completed = False
  rq_find_bottom_not_completed = False
  rq_spiral_not_completed = False

  def ins_actual_force_urcap(direction="X+"):
    axis = str_at(direction, 0)
    if (axis == "x") or (axis == "X"):
      return norm(get_applied_tcp_force(0))
    elif (axis == "y") or (axis == "Y"):
      return norm(get_applied_tcp_force(1))
    elif (axis == "z") or (axis == "Z"):
      return norm(get_applied_tcp_force(2))
    else:
      textmsg("ins_actual_force_urcap, invalid direction ", direction)
    end
  end

  def ins_actual_torque_urcap(direction = "Z+"):
    if (direction == "X+") or (direction == "X-") or (direction == "X"):
      return get_applied_tcp_force(3)
    elif (direction == "Y+") or (direction == "Y-") or (direction == "Y"):
      return get_applied_tcp_force(4)
    else:
      return get_applied_tcp_force(5)
    end

  end

  def square(a):
    return a*a
  end

  def update_servoj_node_target(target_joint_pos):
    set_servoj_node_cmd(target_joint_pos)
    sleep(rq_controller_time_step)
  end

  def create_all_insertion_nodes():
    global rq_insertion_force_node_id = node_rpc_server.createnewforcenode()
    global rq_insertion_movej_node_id = node_rpc_server.createnewmovejnode()
    global rq_insertion_servoj_node_id = node_rpc_server.createnewservojnode()
    node_rpc_server.setparentid(rq_insertion_movej_node_id, rq_insertion_force_node_id)
    node_rpc_server.setparentid(rq_insertion_servoj_node_id, rq_insertion_force_node_id)
  end

  def get_offset_projected_in_spiral_plane(direction, current_pose, pose_ref):
    axis = str_at(direction, 0)
    axis_index = 0
    if axis == "X":
      axis_index = 0
    elif axis == "Y":
      axis_index = 1
    elif axis == "Z":
      axis_index = 2
    else:
      textmsg("get_offset_projected_in_spiral_plane, invalid direction ", direction)
    end

    pose_offset = pose_trans( pose_inv(pose_ref), current_pose ) # current_pose and pose_ref should have the same orientations.
                                                                 # pose_offset is returned expressed in pose_ref frame

    pose_offset[axis_index] = 0 # valeur en direction mise a zero
    pose_offset[3] = 0 # valeur en Rx mise a zero
    pose_offset[4] = 0 # valeur en Ry mise a zero
    pose_offset[5] = 0 # valeur en Rz mise a zero

    return pose_offset
  end

  def update_spiral_offset(direction, spiral_initial_pose, spiral_initial_pose_offset, spiral_initial_pose_offset_name):
    pos_diff_tcp = get_offset_projected_in_spiral_plane(direction, get_actual_tcp_pose(), spiral_initial_pose)
    spiral_initial_pose_offset = interpolate_pose(spiral_initial_pose_offset, pos_diff_tcp, 0.35)
    storevar.setvariablepose(spiral_initial_pose_offset_name, spiral_initial_pose_offset)
  end

  def determine_max_spiral_radius_from_actual_position(direction, spiral_initial_pose, max_radius):
      dist_to_initial_pose = norm( get_offset_projected_in_spiral_plane(direction, get_actual_tcp_pose(), spiral_initial_pose))
      if (max_radius > dist_to_initial_pose):
        new_max_radius = max_radius - dist_to_initial_pose
      else:
        new_max_radius = 0
      end

      return new_max_radius
  end

  def insertion_compliant_move_urcap(axis = "Z",
                                     direction_sign = 1,
                                     compliant_insert_force_threshold = 20,
                                     speed = 0.04,
                                     feature = 1,
                                     max_position_deviation = 0.1):
    feature_base = 0
    feature_tool = 1

    if axis == "X":
      axis_index = 0
    elif axis == "Y":
      axis_index = 1
    elif axis == "Z":
      axis_index = 2
    else:
      textmsg("insertion_compliant_move_urcap, invalid direction ", axis)
    end

    current_pose = get_actual_tcp_pose()
    insertion_offset = p[0,0,0,0,0,0]
    rq_actual_to_destination = pose_trans(pose_inv(current_pose), rq_ins_destination)
    insertion_offset[axis_index] = rq_actual_to_destination[axis_index]
    insertion_pose = pose_trans(current_pose, insertion_offset)
    distance = point_dist(current_pose, insertion_pose)
    number_of_steps = floor( distance / (speed * rq_controller_time_step) ) + 1
    alpha_step  = 1.0 / number_of_steps

    # initialize forcenode
    node_execution_thread = initialise_force_node(position_controlled_direction = axis_index,
                                                  feature = feature_tool,
                                                  max_position_deviation = max_position_deviation)

    alpha = 0.0
    surface_found = False
    while (alpha <= 1.0) and (not surface_found):
      alpha = alpha + alpha_step
      interpolated_pose = interpolate_pose(current_pose, insertion_pose, alpha)
      q0 = get_inverse_kin(interpolated_pose) # define waypoint target
      update_servoj_node_target(q0)
      force = 0
      if feature == feature_base:
        force = get_applied_base_force(axis_index)
      elif feature == feature_tool:
        force = get_applied_tcp_force(axis_index)
      end
      if (direction_sign * force) >= compliant_insert_force_threshold:
        surface_found = True
      end
    end

    final_pos_reached = (alpha >= 1)

    kill_thread( node_execution_thread )

    return final_pos_reached
  end # insertion_compliant_move_urcap

  def insert_spiral_find_hole(axis = "Z", direction_sign = 1,
                              stop_force_threshold = 3,
                              max_radius = 0.005,
                              radius_incr_per_turn = 0.0003,
                              peck_mode = False,
                              tangential_speed = 0.005):

    if (stop_force_threshold < 0) or (stop_force_threshold > 40):
      popup("stop_force_threshold parameter in Newton must be between 0 and 40 Newtons","ERROR rq_insert_spiral_urcap")
      halt
    end
    if (max_radius < 0) or (max_radius > 0.05):
      popup("max_radius parameter must be between 0 mm and 50 mm","ERROR rq_insert_spiral_urcap")
      halt
    end
    if (radius_incr_per_turn < 0.00001) or (radius_incr_per_turn > 0.005):
      popup("radius_incr_per_turn parameter in mm must be between 0.01 mm and 5 mm","ERROR rq_insert_spiral_urcap")
      halt
    end

    rq_spiral_not_completed = False

    ins_x = 0
    ins_y = 0
    ins_z = 0
    ins_pose = p[0, 0, 0, 0, 0, 0]
    ins_current_pos = p[0, 0, 0, 0, 0, 0]
    ins_actual_angle = 0
    ins_search_result = False
    ins_radius_offset = 0
    ins_PI = 3.14159
    radius_inc_per_rad = radius_incr_per_turn / (2*ins_PI)
    ins_actual_radius = 0.0001  #Start radius
    ins_desired_arc_length = tangential_speed * rq_controller_time_step

    sleep(rq_controller_time_step)
    #Find the bore of the part
    ins_current_pos = get_actual_tcp_pose()
    sleep(rq_controller_time_step)

    # if axis == "Z"
    search_axis = 2
    other_axis_A = 0
    other_axis_B = 1
    if (axis == "X"):
      search_axis = 0
      other_axis_A = 1
      other_axis_B = 2
    elif (axis == "Y"):
      search_axis = 1
      other_axis_A = 2
      other_axis_B = 0
    end

    #********************************************************************************************************************
    #Spiral Search using any Axis
    #********************************************************************************************************************
    while ((ins_actual_radius <= max_radius) and (ins_actual_force_urcap(axis) >= stop_force_threshold)):
      if peck_mode:
        #Fragile mode, the robot rises between each new point
        #Retreat from position
        ins_pose[search_axis] = -0.002 * direction_sign
        next_tcp_pose = pose_trans(ins_current_pos,ins_pose)
        movej(next_tcp_pose)
        sleep(0.1)
        #Rotate
        ins_desired_arc_length = 0.0005
        delta_angle = ins_desired_arc_length / ins_actual_radius #small angle approximation
        ins_actual_angle = ins_actual_angle + delta_angle

        ins_pose[other_axis_A] = cos( ins_actual_angle ) * ins_actual_radius
        ins_pose[other_axis_B] = sin( ins_actual_angle ) * ins_actual_radius

        ins_actual_radius = ins_actual_angle * radius_inc_per_rad + ins_radius_offset
        next_tcp_pose = pose_trans(ins_current_pos, ins_pose)
        movej(next_tcp_pose)
        sleep(0.1)
        #Re-establish contact with the part
        ins_pose[search_axis] = 0.0005 * direction_sign
        next_tcp_pose = pose_trans(ins_current_pos, ins_pose)
        movel(next_tcp_pose, a=0.6, v=rq_ins_speed_setting)
        sleep(0.2)
      else:
        #standard mode: the Spiral_Search function will maintain contact between both mating parts at all times
        ins_pose[other_axis_A] = cos( ins_actual_angle ) * ins_actual_radius
        ins_pose[other_axis_B] = sin( ins_actual_angle ) * ins_actual_radius

        delta_angle = ins_desired_arc_length / ins_actual_radius
        ins_actual_angle = ins_actual_angle + delta_angle
        ins_actual_radius = ins_actual_angle * radius_inc_per_rad + ins_radius_offset
        next_tcp_pose = pose_trans(ins_current_pos,ins_pose)
        next_joint_pos = get_inverse_kin(next_tcp_pose)
        servoj(next_joint_pos, 0.1, 0.1, rq_controller_time_step, 0.05, 500)
      end
    end # while loop
    if (ins_actual_radius <= max_radius ):
      ins_search_result = True
    else:
      ins_search_result = False
      rq_spiral_not_completed = True
    end
    stopj(2)
    return ins_search_result

  end # insert_spiral_find_hole

  ####################  SPIRAL #############################
  def rq_insert_spiral_urcap(direction = "Z",
                             stop_force_threshold = 3,
                             max_radius = 0.005,
                             radius_incr = 0.0003,
                             peck_mode = False,
                             tangential_speed = 0.005,
                             compliant_insert_force_threshold = 10,
                             spiral_initial_pose_offset_name = "defaultname",
                             intelligent_approach_enabled = False):

    max_radius = max_radius / 1000 #TODO: change unit to meters and remove this line
    radius_incr = radius_incr / 1000 #TODO: change unit to meters and remove this line

    if (rq_insertion_force_node_id == -1):
      create_all_insertion_nodes()
    end

    hole_found = False
    spiral_bottom_target_reached = False
    number_of_failed_spiral_tries = 0
    number_of_spiral_tries_max = 5
    max_position_deviation = max_radius

    # define the direction sign from rq_ins_destination
    current_pose = get_actual_tcp_pose()
    rq_actual_to_destination = pose_trans(pose_inv(current_pose), rq_ins_destination)
    axis = str_at(direction, 0)
    direction_sign = 1
    direction = str_cat(axis,"+")
    if axis == "X":
      axis_index = 0
    elif axis == "Y":
      axis_index = 1
    elif axis == "Z":
      axis_index = 2
    else:
      textmsg("spiral insert, invalid direction ", direction)
    end
    if (rq_actual_to_destination[axis_index] < 0):
      direction_sign = -1
      direction = str_cat(axis,"-")
    end

    # linearsearch param
    lin_search_stop_force_threshold = compliant_insert_force_threshold
    spiral_initial_pose = get_actual_tcp_pose()
    if intelligent_approach_enabled:
      #adjust position using previous succesfull insertion final position
      spiral_initial_pose_offset = storevar.getvariablepose(spiral_initial_pose_offset_name, p[0,0,0,0,0,0])
      spiral_initial_pose_refined = pose_trans(spiral_initial_pose, spiral_initial_pose_offset)
      movel(spiral_initial_pose_refined, a = 0.1, v = 0.01)
      sleep(0.01)
    end
    while ( (spiral_bottom_target_reached == False) and (number_of_failed_spiral_tries < number_of_spiral_tries_max) ):
      rq_actual_to_destination = pose_trans(pose_inv(get_actual_tcp_pose()), rq_ins_destination)
      max_distance = norm( rq_actual_to_destination[axis_index] )
      contact_initiated = rq_linear_search_urcap(direction, lin_search_stop_force_threshold, tangential_speed, max_distance, 1)
      if contact_initiated:
        new_max_radius = determine_max_spiral_radius_from_actual_position(direction, spiral_initial_pose, max_radius)
        hole_found = insert_spiral_find_hole(axis, direction_sign, stop_force_threshold, new_max_radius, radius_incr, peck_mode, tangential_speed)
        if (hole_found == True): # if hole is found, try to insert
          max_force_control_position_deviation = determine_max_spiral_radius_from_actual_position(direction, spiral_initial_pose, max_radius)
          spiral_bottom_target_reached = insertion_compliant_move_urcap(axis, direction_sign, compliant_insert_force_threshold, tangential_speed, 1, max_force_control_position_deviation)
          if spiral_bottom_target_reached:
            if intelligent_approach_enabled:
              update_spiral_offset(direction, spiral_initial_pose, spiral_initial_pose_offset, spiral_initial_pose_offset_name) # update actual hole position.
            end
          else:
            textmsg("Insertion spiral: could not reach hole bottom")
          end
        else:
          textmsg("Insertion error: hole was not found after contact")
          break
        end
      else: # linear_search reached the teach position without contact
          spiral_bottom_target_reached = True
      end # if contact_initiated
      number_of_failed_spiral_tries = number_of_failed_spiral_tries + 1
    end # while
    return (not spiral_bottom_target_reached)
  end # rq_insert_spiral_urcap

  def insertion_finish_move_urcap(direction = "Z+"):
    insertion_offset = p[0,0,0,0,0,0]
    current_pose = get_actual_tcp_pose()
    rq_actual_to_destination = pose_trans(pose_inv(current_pose), rq_ins_destination)
    axis = str_at(direction, 0)
    if axis == "X":
      insertion_offset = p[rq_actual_to_destination[0],0,0,0,0,0]
    elif axis == "Y":
      insertion_offset = p[0,rq_actual_to_destination[1],0,0,0,0]
    elif axis == "Z":
      insertion_offset = p[0,0,rq_actual_to_destination[2],0,0,0]
    else:
      textmsg("insertion_finish_move_urcap, invalid direction ", direction)
    end
    insertion_pose = pose_trans(current_pose, insertion_offset)
    movel(insertion_pose, a=0.05, v=rq_ins_speed_setting)
  end

  def rq_xor(a, b):
    return (a and not(b)) or (not(a) and b)
  end

  def rq_adapt_force_control_to_direction(position_controlled_direction = 2, feature = 1, max_position_deviation = 0.1):
    force_control_enabled_vector = [True, True, True, False, False, False]
    force_control_enabled_vector[position_controlled_direction] = False
    targetForce = [0, 0, 0, 0, 0, 0]
    max_negative_deviation_vector = [-max_position_deviation, -max_position_deviation, -max_position_deviation, 0, 0, 0]
    max_positive_deviation_vector = [max_position_deviation, max_position_deviation, max_position_deviation, 0, 0, 0]
    max_negative_deviation_vector[position_controlled_direction] = 0
    max_positive_deviation_vector[position_controlled_direction] = 0
    adaptiveStiffness = True
    setup_force_node_on_server(rq_insertion_force_node_id,
                               feature, targetForce,
                               force_control_enabled_vector,
                               max_negative_deviation_vector,
                               max_positive_deviation_vector,
                               adaptiveStiffness)
  end

  def initialise_force_node(position_controlled_direction = 2, feature = 1, max_position_deviation = 0.1):
    movej(get_actual_joint_positions()) # This moveJ is used to prevent "another thread is already controlling the robot error".
    rq_adapt_force_control_to_direction(position_controlled_direction = position_controlled_direction,
                                        feature = 1,
                                        max_position_deviation = max_position_deviation)
    set_servoj_node_cmd(get_actual_joint_positions())
    reset_node_executor()
    active_and_reset_node(rq_insertion_force_node_id)
    active_and_reset_node(rq_insertion_servoj_node_id)
    node_execution_thread = run execute_node_thread()
    return node_execution_thread
  end

  ####################  ROTATIONAL #############################
  def rq_insert_rotation_urcap(positive_rotation_desired = True,
                               direction="Z",
                               speed = 0.004,
                               force_threshold = 10,
                               rotation_speed = 5,
                               max_angle_deg = 360,
                               peck_mode = False,
                               max_rotation_torque=1):

    speed = speed / 1000 # TODO: change speed input units to meters instead of mm and remove this line
    max_force_control_position_deviation = 0.002 # TODO: add a parameter for this in the interface
    max_torque_reached_counter_fail_threshold = 1/rq_controller_time_step # try for about one second

    if (rq_insertion_force_node_id == -1):
        create_all_insertion_nodes()
    end

    # define the direction sign
    rq_actual_to_destination = pose_trans(pose_inv(get_actual_tcp_pose()), rq_ins_destination)
    axis = str_at(direction, 0)
    direction_sign = 1
    direction = str_cat(axis,"+")
    if axis == "X":
      rq_ins_offset = p[rq_actual_to_destination[0], 0, 0, 0, 0, 0]
      rot_axe = 3
      axis_index = 0
    elif axis == "Y":
      rq_ins_offset = p[0, rq_actual_to_destination[1], 0, 0, 0, 0]
      rot_axe = 4
      axis_index = 1
    elif axis == "Z":
      rq_ins_offset = p[0, 0, rq_actual_to_destination[2], 0, 0, 0]
      rot_axe = 5
      axis_index = 2
    else:
      textmsg("insertion: invalid direction ", direction)
    end
    if (rq_actual_to_destination[axis_index] < 0):
      direction_sign = -1
      direction = str_cat(axis,"-")
      positive_rotation_desired = not positive_rotation_desired
    end

    distance_to_destination = norm( rq_actual_to_destination[axis_index] )

    contact_with_piece_initiated = rq_linear_search_urcap(direction, force_threshold, speed, distance_to_destination, feature = 1)

    if( contact_with_piece_initiated ):

      # verify validity of user inputs
      if ((rotation_speed <= 0) or (rotation_speed > 60)):
        popup("rotation speed parameter in degrees / second must be between 0.01 and 60","ERROR rq_insert_rotation_urcap")
        halt
      elif ((max_rotation_torque < 0.01) or (max_rotation_torque > 15)):
        popup("max_rotation_torque parameter in Newton-meter must be between 0.01 and 15","ERROR rq_insert_rotation_urcap")
        halt
      elif ((max_angle_deg <= 1) or (max_angle_deg > 360)):
        popup("max angle parameter in degree must be between 1 and 360","ERROR rq_insert_rotation_urcap")
        halt
      end

      # initialize forcenode: adapt to direction
      node_execution_thread = initialise_force_node(position_controlled_direction = axis_index,
                                                    feature = 1,
                                                    max_position_deviation = max_force_control_position_deviation)

      if positive_rotation_desired:
        rot_direction_sign = 1
      else:
        rot_direction_sign = -1
      end
      rq_ins_speed_setting = speed
      posrot = p[0,0,0,0,0,0]
      max_rot_angle = d2r(max_angle_deg)
      time_step_signed = rq_controller_time_step * rot_direction_sign * direction_sign
      rot_step = d2r(rotation_speed) * time_step_signed
      rot_step_5deg_per_second = d2r(5) * time_step_signed

      line_step = rq_ins_speed_setting * rq_controller_time_step * direction_sign
      rot_actual_angle = 0
      rot_actual_mode = 1 #1= linear, 2 = rotation
      rot_actual_distance = 0
      ins_rotation_initial_pose = get_actual_tcp_pose()
      rq_actual_to_destination = pose_trans( pose_inv(ins_rotation_initial_pose), rq_ins_destination )
      distance_to_destination = norm( rq_actual_to_destination[axis_index] )
      global rq_insertion_max_torque_reached_counter = 0

      if peck_mode:
        #peck mode
        positive_rotation_computed = positive_rotation_desired
        while ( (norm(rot_actual_distance) < distance_to_destination) and
                (norm(rot_actual_angle) <= max_rot_angle) and
                (rq_insertion_max_torque_reached_counter < max_torque_reached_counter_fail_threshold) ):
          is_max_torque_reached = norm(get_applied_tcp_force(rot_axe)) > max_rotation_torque
          if (ins_actual_force_urcap(direction) >= force_threshold):
            #goes up
            posrot[axis_index] = rot_actual_distance - 0.002 * direction_sign
            next_tcp_pose = pose_trans(ins_rotation_initial_pose, posrot)
            next_joint_pos = get_inverse_kin(next_tcp_pose)
            node_rpc_server.movejdefinewaypoint(rq_insertion_movej_node_id, next_joint_pos, 0.4, 0.4)
            execute_node(rq_insertion_movej_node_id, False )
            #rotate
            rot_actual_angle = compute_rotation_next_angle(rot_actual_angle, 285 * rot_step, is_max_torque_reached) # value of 285 define the peck mode "step size". determined ad oc
            posrot[rot_axe] = rot_actual_angle
            next_tcp_pose = pose_trans(ins_rotation_initial_pose, posrot)
            next_joint_pos = get_inverse_kin(next_tcp_pose)
            node_rpc_server.movejdefinewaypoint(rq_insertion_movej_node_id, next_joint_pos, 1, 1)
            execute_node(rq_insertion_movej_node_id, False )
            #go back in touch with the part
            posrot[axis_index] = rot_actual_distance
            next_tcp_pose = pose_trans(ins_rotation_initial_pose, posrot)
            next_joint_pos = get_inverse_kin(next_tcp_pose)
            node_rpc_server.movejdefinewaypoint(rq_insertion_movej_node_id, next_joint_pos, 0.4, 0.3)
            execute_node(rq_insertion_movej_node_id, False )
            sleep(0.1)
          else:
            rq_insertion_max_torque_reached_counter = 0
            rot_actual_distance = rot_actual_distance + line_step
            posrot[axis_index] = rot_actual_distance
            next_tcp_pose = pose_trans(ins_rotation_initial_pose, posrot)
            next_joint_pos = get_inverse_kin(next_tcp_pose)
            update_servoj_node_target(next_joint_pos)
            if (rq_active_node != rq_insertion_servoj_node_id):
              active_and_reset_node(rq_insertion_servoj_node_id)
            end
          end # if
        end # while
      else:
        #normal mode
        while ( (norm(rot_actual_distance) <= distance_to_destination) and
                (norm(rot_actual_angle) <= max_rot_angle) and
                (rq_insertion_max_torque_reached_counter < max_torque_reached_counter_fail_threshold) ):
          is_max_torque_reached = norm(get_applied_tcp_force(rot_axe)) > max_rotation_torque
          if ( norm(get_applied_tcp_force(axis_index)) >= force_threshold ):
            if (rot_actual_mode == 1):
              rot_actual_distance = rot_actual_distance - line_step
              posrot[axis_index] = rot_actual_distance
            end
            limited_rotation_step = limit_rotation_step_when_close_to_max_angle(rot_step, rot_step_5deg_per_second, max_rot_angle, rot_actual_angle)
            rot_actual_angle = compute_rotation_next_angle(rot_actual_angle, limited_rotation_step, is_max_torque_reached)
            posrot[rot_axe] = rot_actual_angle
            rot_actual_mode = 2
          else:
            rq_insertion_max_torque_reached_counter = 0
            rot_actual_distance = rot_actual_distance + line_step
            posrot[axis_index] = rot_actual_distance
            rot_actual_mode = 1
          end # if
          next_tcp_pose = pose_trans(ins_rotation_initial_pose, posrot)
          next_joint_pos = get_inverse_kin(next_tcp_pose)
          update_servoj_node_target(next_joint_pos)
        end # while
      end # if peck_mode

      kill_thread( node_execution_thread )
      stopj(2)
      rq_rotation_not_completed = ( (norm(rot_actual_angle) > max_rot_angle) or
                                    (rq_insertion_max_torque_reached_counter >= max_torque_reached_counter_fail_threshold) )
    else: # initial find_surface was unsuccessfull, assume a direct hit to target, which is a success
      rq_rotation_not_completed = False
    end # if contact_with_piece_initiated

    return rq_rotation_not_completed
  end # insert rotation 2

  def limit_rotation_step_when_close_to_max_angle(rot_step, minimal_rot_step, max_rot_angle, rot_actual_angle):
    rot_deceleration_angle_distance = d2r(3)
    rot_direction = 1
    if( rot_step < 0 ):
      rot_direction = -1
      rot_step = -1 * rot_step # get positive rot_step for calculation. Direction sign is re-introduced at the end.
    end
    angle_distance_to_max_rot_angle = max_rot_angle - norm(rot_actual_angle)
    if( (angle_distance_to_max_rot_angle < rot_deceleration_angle_distance) and (rot_step > minimal_rot_step) ):
      decelaration_slope = (rot_step - minimal_rot_step) / rot_deceleration_angle_distance
      rot_step_limited = decelaration_slope * angle_distance_to_max_rot_angle + minimal_rot_step
    else:
      rot_step_limited = rot_step
    end
    return ( rot_direction * rot_step_limited )
  end

  def compute_rotation_next_angle(current_angle, step, is_max_torque_reached):
  #This function compute the rotation angle for rotational insertion by
  # incrementing the current angle by the desired step size.
  # If the maximal torque is reached, the rotation goes backward to
  # return to a admissible torque. In the backward direction,
  # a smaller step size is used to prevent constant oscillation between to steps
    if (is_max_torque_reached):
        rq_insertion_max_torque_reached_counter = rq_insertion_max_torque_reached_counter + 1
        new_angle = current_angle - 0.8 * step
    else:
        new_angle = current_angle + step
    end
    return new_angle
  end

  def center_one_axis(axis, lin_search_stop_force_threshold, speed, max_distance, feature):
    # Initiate contact in forward direction
    contact_initiated = rq_linear_search_urcap( str_cat(axis, "+"), lin_search_stop_force_threshold, speed, max_distance, feature)
    if contact_initiated:
      forward_contact_pose = get_actual_tcp_pose()
      # Initiate contact in reverse direction
      contact_initiated = rq_linear_search_urcap(str_cat(axis, "-"), lin_search_stop_force_threshold, speed, max_distance, feature)
      if contact_initiated:
        reverse_contact_pose = get_actual_tcp_pose()
        # Go to average of contact points
        pose_center_1 = interpolate_pose(forward_contact_pose, reverse_contact_pose, 0.5)
        movel(pose_center_1, a=0.6, v=speed)
      end
    end
    return contact_initiated
  end

  def rq_insert_recenter_urcap(axis = "Z", max_distance = 0.1, speed = 0.005, feature = 1, lin_search_stop_force_threshold = 5):

    if (max_distance < 0) or (max_distance > 1):
      popup("max_distance parameter in m must be between 0 and 1","ERROR rq_insert_recenter_urcap")
      halt
    elif (speed < 0.0001) or (speed > 0.5):
      popup("max_radius parameter in mm must be between 0.0001m/s and 0.5m/s","ERROR rq_insert_recenter_urcap")
      halt
    end

    #--------------------------------------------------------------------------------------------------------------------
    #For insertion in the X axis
    #--------------------------------------------------------------------------------------------------------------------
    if (axis == "X"):
      recenter_axis_1 = "Y"
      recenter_axis_2 = "Z"
    #--------------------------------------------------------------------------------------------------------------------
    #For insertion in the Y axis
    #--------------------------------------------------------------------------------------------------------------------
    elif (axis == "Y"):
      recenter_axis_1 = "X"
      recenter_axis_2 = "Z"
    #--------------------------------------------------------------------------------------------------------------------
    #For insertion in the Z axis
    #--------------------------------------------------------------------------------------------------------------------
    elif (axis == "Z"):
      recenter_axis_1 = "X"
      recenter_axis_2 = "Y"
    end

    recenter_successfull = center_one_axis(recenter_axis_1, lin_search_stop_force_threshold, speed, max_distance, feature)
    if recenter_successfull:
      recenter_successfull = center_one_axis(recenter_axis_2, lin_search_stop_force_threshold, speed, max_distance, feature)
    end

    if (recenter_successfull == False):
      textmsg("rq_insert_recenter_urcap failed, could not initiate contact with piece")
    end

    return recenter_successfull
  end # rq_insert_recenter_urcap

  # ******************* MAIN of Insertion Preamble *******************
  storevar.clearall()
  global rq_insertion_force_node_id = -1
  def rq_linear_search_common_validation(abs_max_distance, speed, force_threshold):
    if (abs_max_distance > 2.0):
      popup("maximum distance parameter in meters must be between 0 and 2.0","ERROR rq_linear_search_urcap")
      halt
    elif (speed < 0.0001) or (speed > 0.15):
      popup("speed parameter in mm/s must be between 0.1 and 150","ERROR rq_linear_search_urcap")
      halt
    elif (force_threshold < 0.0) or (force_threshold > 200):
      popup("Force parameter in Newtons must be between 0 and 200","ERROR rq_linear_search_urcap")
      halt
    end
  end

  def rq_linear_search_get_direction_sign(direction):
    sign = str_at(direction, 1)
    direction_sign = 1
    if sign == "-":
      direction_sign = -1
    end
    return direction_sign
  end

  def rq_linear_search_get_force_index(direction):
    axis = str_at(direction, 0)
    force_index = 0
    if (axis == "X") or (axis == "x"):
      force_index = 0
    elif (axis == "Y") or (axis == "y"):
      force_index = 1
    elif (axis == "Z") or (axis == "z"):
      force_index = 2
    else:
      popup("direction parameter must be X+, X-, Y+, Y-, Z+ or Z-","ERROR rq_linear_search_urcap")
      halt
    end
    return force_index
  end

  def rq_linear_search_get_pose_offset(force_index, max_distance):
    pose_offset = p[0,0,0,0,0,0]
    pose_offset[force_index] = max_distance
    return pose_offset
  end

  def rq_linear_search_execution(pose_from, pose_to, force_threshold, speed, T_tcp_to_force_frame, force_index, direction_sign):
    steptime = rq_controller_time_step
    distance = point_dist(pose_from, pose_to)
    number_pose_interpolate = floor(distance / (speed * steptime)) + 1
    delta_alpha = 1.0 / number_pose_interpolate

    alpha = 0.0
    local surface_found = False

    pose_step = 0
    end_pose_pause_time = 0.2 # to refine
    max_pose_steps = number_pose_interpolate + end_pose_pause_time/steptime
    while (pose_step < max_pose_steps) and (not surface_found):
      pose_step = pose_step + 1
      alpha = pose_step * delta_alpha
      if (alpha < 1.0):
        pose_interpolate = interpolate_pose(pose_from, pose_to, alpha)
      else:
        pose_interpolate = pose_to
      end

      servoj(get_inverse_kin(pose_interpolate), 0.1, 0.1, steptime, 0.05, 500)

      wrench = express_force_in_frame(T_tcp_to_force_frame, tcp_wrench)
      applied_force = -1 * wrench[force_index]

      if (direction_sign * applied_force) >= force_threshold:
        surface_found = True
      end
    end

    return surface_found
  end

  #************************************************
  #Function:  rq_linear_search_urcap(direction="Z+", force[N] = 10, speed[m/s] = 0.004, max_distance[m] = 0.02)
  #   Find a specific force in the direction of "direction".
  #   Robot will move towards a max_distance from the current position in the tool frame
  #   Return True if the force is detected during the robot motion
  #
  #************************************************
  def rq_linear_search_urcap(direction="Z+", force_threshold = 10, speed = 0.004, max_distance = 0.02, feature = 0 ):

    rq_linear_search_common_validation(max_distance, speed, force_threshold)
    if (feature != 0) and (feature != 1):
      popup("feature value should be 0 for base or 1 for tool","ERROR rq_linear_search_urcap")
      halt
    end

    feature_base = 0
    feature_tool = 1

    force_index = rq_linear_search_get_force_index(direction)
    direction_sign = rq_linear_search_get_direction_sign(direction)
    max_distance = direction_sign * max_distance
    pose_offset = rq_linear_search_get_pose_offset(force_index, max_distance)

    tcp_pose = get_actual_tcp_pose()
    pose_from = tcp_pose
    pose_to = pose_from
    if feature == feature_base:
      pose_to = pose_add(pose_from, pose_offset)
    elif feature == feature_tool:
      pose_to = pose_trans(pose_from, pose_offset)
    end

    T_tcp_to_force_frame = p[0, 0, 0, 0, 0, 0] # default for feature_tool
    if (feature == feature_base):
      T_tcp_to_force_frame = pose_inv(tcp_pose)
    end

    surface_found = rq_linear_search_execution(pose_from, pose_to, force_threshold, speed, T_tcp_to_force_frame, force_index, direction_sign)

    return surface_found
  end

  def rq_linear_search_custom_frame(direction="Z+", force_threshold = 10, speed = 0.004, abs_max_distance = 0.02, feature_frame = p[0, 0, 0, 0, 0, 0]):

    rq_linear_search_common_validation(abs_max_distance, speed, force_threshold)

    force_index = rq_linear_search_get_force_index(direction)
    direction_sign = rq_linear_search_get_direction_sign(direction)
    max_distance = direction_sign * abs_max_distance
    pose_offset = rq_linear_search_get_pose_offset(force_index, max_distance)

    tcp_pose = get_actual_tcp_pose()
    offset_frame = p[tcp_pose[0], tcp_pose[1], tcp_pose[2], feature_frame[3], feature_frame[4], feature_frame[5]]
    tcp_position_with_offset = pose_trans(offset_frame, pose_offset)
    pose_from = tcp_pose
    pose_to = p[tcp_position_with_offset[0], tcp_position_with_offset[1], tcp_position_with_offset[2], tcp_pose[3], tcp_pose[4], tcp_pose[5]]

    T_tcp_to_force_frame = pose_trans(pose_inv(tcp_pose), feature_frame)

    surface_found = rq_linear_search_execution(pose_from, pose_to, force_threshold, speed, T_tcp_to_force_frame, force_index, direction_sign)

    return surface_found
  end

  def validate_wait_for_force_drop_common_parameters(force_threshold, timeout_seconds):
    if (timeout_seconds < 0.0) or (timeout_seconds > 3600):
      popup("timeout parameter in s must be between 0 and 3600","ERROR rq_wait_for_force_drop")
      halt
    elif (force_threshold < 0.0) or (force_threshold > 200):
      popup("Force parameter in Newtons must be between 0 and 200","ERROR rq_wait_for_force_drop")
      halt
    end
  end

  def rq_wait_for_force_drop_execution(force_threshold, T_tcp_to_force_frame, force_index, direction_sign, timeout_seconds):
    local steptime = get_steptime()
    local release_detected = False
    local time = 0

    while (time < timeout_seconds) and (not release_detected):
      time = time + steptime

      local wrench = express_force_in_frame(T_tcp_to_force_frame, tcp_wrench)
      local force = -1 * wrench[force_index]

      if (direction_sign * force) < force_threshold:
        release_detected = True
      end
      sync()
    end

    return release_detected
  end

  def rq_wait_for_force_drop_custom_frame(direction="Z+", force_threshold = 10, timeout_seconds = 60, feature_frame = p[0, 0, 0, 0, 0, 0] ):
    validate_wait_for_force_drop_common_parameters(force_threshold, timeout_seconds)

    local force_index = rq_linear_search_get_force_index(direction)
    local direction_sign = rq_linear_search_get_direction_sign(direction)

    local tcp_pose = get_actual_tcp_pose()
    local T_tcp_to_force_frame = pose_trans(pose_inv(tcp_pose), feature_frame)

    local release_detected = rq_wait_for_force_drop_execution(force_threshold, T_tcp_to_force_frame, force_index, direction_sign, timeout_seconds)

    return release_detected
  end

  def rq_wait_for_force_drop(direction="Z+", force_threshold = 10, timeout_seconds = 60, feature = 0 ):
    validate_wait_for_force_drop_common_parameters(force_threshold, timeout_seconds)
    if (feature != 0) and (feature != 1):
      popup("feature value should be 0 for base or 1 for tool","ERROR rq_wait_for_force_drop")
      halt
    end

    local force_index = rq_linear_search_get_force_index(direction)
    local direction_sign = rq_linear_search_get_direction_sign(direction)

    local feature_base = 0
    local feature_tool = 1
    local tcp_pose = get_actual_tcp_pose()
    local T_tcp_to_force_frame = p[0, 0, 0, 0, 0, 0] # default for feature_tool
    if (feature == feature_base):
      T_tcp_to_force_frame = pose_inv(tcp_pose)
    end

    local release_detected = rq_wait_for_force_drop_execution(force_threshold, T_tcp_to_force_frame, force_index, direction_sign, timeout_seconds)

    return release_detected
  end



    ##############################################
    # OFFSET FEATURE-RELATED VARIABLES AND METHODS
    ##############################################
    def cross_product(vector1,vector2):
      v_temp=[0,0,0]
      v_temp[0]=vector1[1]*vector2[2]-vector1[2]*vector2[1]
      v_temp[1]=vector1[2]*vector2[0]-vector1[0]*vector2[2]
      v_temp[2]=vector1[0]*vector2[1]-vector1[1]*vector2[0]
      return v_temp
    end

    def relocate_xyzr(init_feature, init_touch_pose, touch_pose):
      init_touch_pose_2_init_feature = pose_trans( pose_inv(init_touch_pose), init_feature)
      new_feature = pose_trans( touch_pose, init_touch_pose_2_init_feature )

      return new_feature
    end

    def relocate_orientation(touch1_init_pose, touch2_init_pose, feature_init_pose, touch1_pose, touch2_pose):
      #when relocating using 2 touch, the center of rotation is around touch point 1 (this could be changed)

      # initial touch2 pose in initial touch 1 pose frame:
      touch2_initial_pose_in_touch1_initial_pose_frame = pose_trans(pose_inv(touch1_init_pose), touch2_init_pose)

      # find theoric touch2_pose if no rotation
      touch2_pose_if_no_rotation = pose_trans(touch1_pose, touch2_initial_pose_in_touch1_initial_pose_frame)

      # vectors touch1 to touch2
      touch1_pose_to_touch2_pose = pose_trans(pose_inv(touch1_pose), touch2_pose)
      touch1_pose_to_touch2_pose_if_no_rotation = pose_trans(pose_inv(touch1_pose), touch2_pose_if_no_rotation)

      #angle axis calculation
      normal_vector = cross_product(touch1_pose_to_touch2_pose_if_no_rotation, touch1_pose_to_touch2_pose)
      normal_vector_norm = norm(normal_vector)
      if (normal_vector_norm > 10e-6):
        rotation_angle_rad = asin( normal_vector_norm / (norm(touch1_pose_to_touch2_pose_if_no_rotation) * norm(touch1_pose_to_touch2_pose) ) )
        normal_vector_to_angle_axis_multiply_norm_factor = rotation_angle_rad / normal_vector_norm
        angle_axis = [normal_vector[0] * normal_vector_to_angle_axis_multiply_norm_factor, normal_vector[1] * normal_vector_to_angle_axis_multiply_norm_factor, normal_vector[2] * normal_vector_to_angle_axis_multiply_norm_factor]
        rotation_offset_pose = p[0, 0, 0, angle_axis[0], angle_axis[1], angle_axis[2]]

        #rotate touch1 pose using touch2 information
        touch1_pose_rotated = pose_trans(touch1_pose, rotation_offset_pose)
      else:
        touch1_pose_rotated = touch1_pose
      end

      # relocate the feature using touch1_rotated_pose
      return relocate_xyzr(feature_init_pose, touch1_init_pose, touch1_pose_rotated)
    end

    def relocate_1_touch(touch_init_pose, touch_pose, feature_init_pose, feature_actual_pose):
      touch_initial_pose_in_initial_feature_frame = pose_trans(pose_inv(feature_init_pose), touch_init_pose)
      touch_actual_pose_in_actual_feature_frame = pose_trans(pose_inv(feature_actual_pose), touch_pose)

      # difference between touch poses in their respective feature frame
      touch_pose_offset = pose_sub(touch_actual_pose_in_actual_feature_frame, touch_initial_pose_in_initial_feature_frame)

      # remove all rotation from offset
      touch_pose_offset[3] = 0
      touch_pose_offset[4] = 0
      touch_pose_offset[5] = 0

      # apply pose offset to actual feature
      return pose_trans(feature_actual_pose, touch_pose_offset)
    end
    ##############################################
    # PALLETIZER INITIALIZATION
    ##############################################
    if(not palletizerXmlRpcClient.acknowledgePalletStates()):
      checkForScriptPreparationException()
      halt
    end

    ##############################################
    # PALLETIZER-RELATED VARIABLES AND METHODS
    ##############################################

    palletizerXmlRpcClient.setCurrentPalletizerNode("")

    def rq_get_nb_processed_boxes():
      rq_palletizer_uuid = palletizerXmlRpcClient.getCurrentPalletizerNode()
      if rq_palletizer_uuid == "":
        popup("rq_get_nb_processed_boxes() should only be called from within a Palletizer node.", title="Palletizer", error=True, blocking=True)
        halt
      end

      rq_box_count = palletizerXmlRpcClient.getCurrentBoxCount(rq_palletizer_uuid)
      if rq_box_count == -1:
        popup("Invalid Palletizer node id used for rq_get_nb_processed_boxes()", title="Palletizer", error=True, blocking=True)
        halt
      end
      return rq_box_count
    end

    def rq_get_current_box_type():
         rq_palletizer_uuid = palletizerXmlRpcClient.getCurrentPalletizerNode()
         if rq_palletizer_uuid == "":
            popup("rq_get_current_box_type() should only be called from within a Palletizer node.", title="Palletizer", error=True, blocking=True)
            halt
         end

         rq_box_type_name = palletizerXmlRpcClient.getCurrentBoxTypeName(rq_palletizer_uuid)
         return rq_box_type_name
    end

     def rq_get_current_pal_recipe():
         rq_palletizer_uuid = palletizerXmlRpcClient.getCurrentPalletizerNode()
         if rq_palletizer_uuid == "":
            popup("rq_get_current_pal_recipe() should only be called from within a Palletizer node.", title="Palletizer", error=True, blocking=True)
            halt
         end

         rq_pal_unit_load_name = palletizerXmlRpcClient.getCurrentPalletUnitLoadName(rq_palletizer_uuid)
         return rq_pal_unit_load_name
     end

    def rq_set_pallet_completed():
      rq_palletizer_uuid = palletizerXmlRpcClient.getCurrentPalletizerNode()
      if rq_palletizer_uuid == "":
        popup("rq_set_pallet_completed() should only be called from within a Palletizer node.", title="Palletizer", error=True, blocking=True)
        halt
      end

      palletizerXmlRpcClient.skipToAfterPallet(rq_palletizer_uuid)
    end

    def rq_demo_mode_switch_palletizer_mode():
      palletizerXmlRpcClient.demoModeFakePalletSwapAndAndSwitchPalletizerMode()
    end

    def rq_linear_axis_scan(halt_on_error=True):
      local succeeded = False
      local error_message = ""

      if not node_rpc_server.linearaxisconnected():
        succeeded = node_rpc_server.linearaxisscan()
        if succeeded:
          textmsg("Linear axis scanned successfully")
        else:
          error_message = "rq_linear_axis_scan() was unable to find linear axis"
        end
      else:
        succeeded = True
        textmsg("Linear axis already connected")
      end

      if not succeeded:
        if halt_on_error:
          popup(error_message, title="Linear Axis", error=True, blocking=True)
          halt
        else:
          textmsg(error_message)
        end
      end

      return succeeded
    end

    def rq_linear_axis_start(halt_on_error=True):
      local succeeded = False
      local error_message = ""

      if not node_rpc_server.linearaxisconnected():
        error_message = "rq_linear_axis_start() was unable to start linear axis : linear axis not connected"
      else:
        succeeded = node_rpc_server.linearaxisstart()
        if succeeded:
          textmsg("Linear axis started successfully")
        else:
          error_message = "rq_linear_axis_start() was unable to start linear axis"
        end
      end

      if not succeeded:
        if halt_on_error:
          popup(error_message, title="Linear Axis", error=True, blocking=True)
          halt
        else:
          textmsg(error_message)
        end
      end

      return succeeded
    end

    def rq_linear_axis_disable(halt_on_error=True):
      local succeeded = False
      local error_message = ""

      if not node_rpc_server.linearaxisconnected():
        error_message = "rq_linear_axis_disable() was unable to disable linear axis : linear axis not connected"
      else:
        succeeded = node_rpc_server.linearaxisdisable()
        if succeeded:
          textmsg("Linear axis disabled successfully")
        else:
          error_message = "rq_linear_axis_disable() was unable to disable linear axis"
        end
      end

      if not succeeded:
        if halt_on_error:
          popup(error_message, title="Linear Axis", error=True, blocking=True)
          halt
        else:
          textmsg(error_message)
        end
      end

      return succeeded
    end

    global rq_palletizer_state_changed = False
    def rq_set_palletizer_state(palletizer_index, processed_boxes, next_step, other_pallet_state="ABSENT", current_pallet="CURRENT", left_recipe="", right_recipe=""):
      palletizerXmlRpcClient.setPalletizerState(palletizer_index, processed_boxes, next_step, other_pallet_state, current_pallet, left_recipe, right_recipe)
      checkForScriptPreparationException()
      rq_palletizer_state_changed = True
    end

    def rq_get_pallet_state(is_pallet_left):
      return node_rpc_server.getPalletState(is_pallet_left)
    end
    ###############################################################
    # Linear Axis Move related methods
    ###############################################################
    def verify_is_in_linear_axis_range(target_axis_position):
      axis_position_range = node_rpc_server.linearaxisgetpositionrange()

      if target_axis_position < axis_position_range[0] or target_axis_position > axis_position_range[1]:
        textmsg("Linear axis target position : ", target_axis_position)
        textmsg("Linear axis position range : ", axis_position_range)
        popup("Linear axis position is unreachable.", "Linear Axis Move", blocking=True, error=True)
        halt
      end
    end

    def rq_get_linear_axis_pos():
        axis_position = node_rpc_server.linearaxisgetactualposition()
        textmsg("Linear axis actual position : ", axis_position)
        return axis_position
    end

  BLOW_OFF_MODE_NO_AIR = 0
  BLOW_OFF_MODE_SMART_AIR = 1
  UNDEFINED_THREAD_ID = -1
  MODBUS_TYPE = "MODBUS"
  STANDARD_TYPE = "STANDARD"
  INVALID_OUTPUT_ADDRESS = -1
  RQ_UNUSED_TIMEOUT = -1

  global rq_cnc_insertion_node_ids = [-1, -1]
  global rq_run_timeout = 30

  ###################################################################################
  #
  # Generic methods
  #
  ###################################################################################

  def bool_to_str(value):
    if value:
      return "true"
    else:
      return "false"
    end
  end

  def bool_array_to_string(array, index):
    if (index >= length(array)):
      return "]"
    end

    separator = ","
    if (index == length(array) - 1):
      separator = ""
    end

    if (index == 0):
      str_array = concat("[", bool_to_str(array[index]), separator)
      return str_cat(str_array, bool_array_to_string(array, index + 1))
    else:
      return concat(bool_to_str(array[index]), separator, bool_array_to_string(array, index + 1))
    end
  end

  def rq_bool_array_to_string(array):
    return bool_array_to_string(array, 0)
  end

  def json_force_node(force, max_negative_deviation, max_positive_deviation, stiffness, enabled_axis, feature, is_adaptive):
    json = "{"
    json = concat(json, key_val("forceFrame", feature), ",")
    json = concat(json, key_val("isAdaptive", is_adaptive), ",")
    json = concat(json, key_val("isForceControlAboutActualPosition", "false"), ",")
    json = concat(json, key_val("isForceMode", enabled_axis), ",")
    json = concat(json, key_val("maxNegativeDeviation", max_negative_deviation), ",")
    json = concat(json, key_val("maxPositiveDeviation", max_positive_deviation), ",")
    json = concat(json, key_val("stiffness", stiffness), ",")
    json = concat(json, key_val("targetTcpWrench", force), "}")
    return json
  end

  def rq_setup_machine_tending_force_node(feature, force, stiffness, max_negative_deviation, max_positive_deviation, enabled_axis, is_adaptive):
    force_node_id = node_rpc_server.createnewforcenode()
    node_rpc_server.fromjson(force_node_id, json_force_node(force, max_negative_deviation, max_positive_deviation, stiffness, enabled_axis, 1, is_adaptive))
    return force_node_id
  end

  ###################################################################################
  #
  # TRAJECTORY UTILITIES
  #
  ###################################################################################

  def dot_product(v1, v2):
    return [v1]*transpose(v2)
  end

  def get_symmetric_poses_from_middle(p1, p2, middle_pose, distance):
    distance_p1_middle = point_dist(p1, middle_pose)
    alpha = (distance / 2) / distance_p1_middle
    start_pose = interpolate_pose(middle_pose, p1, alpha)
    end_pose = interpolate_pose(middle_pose, p2, alpha)

    return [start_pose, end_pose]
  end

  def translate_to_origin(pose):
    return p[0, 0, 0, pose[3], pose[4], pose[5]]
  end


  ###################################################################################
  #
  # ROBOTIQ PART PRESENTER
  #
  ###################################################################################

  global cnc_part_presenter_index = 0

  def rq_pallet_get_poses_from_index(p_corner_1_approach, p_corners, nb_rows, nb_columns, alternate_direction, index):
      row = floor(index / nb_columns)
      column = index % nb_columns

      row_alpha = 0
      if(nb_rows > 1):
          row_alpha = row / (nb_rows - 1)
      end

      p_row_start = interpolate_pose(p_corners[0], p_corners[3], row_alpha)
      p_row_end = interpolate_pose(p_corners[1], p_corners[2], row_alpha)

      column_alpha = 0
      if(nb_columns > 1):
          column_alpha = column / (nb_columns - 1)
      end

      if(alternate_direction and (row % 2) and nb_columns > 1):
          pallet_pose = interpolate_pose(p_row_end, p_row_start, column_alpha)
      else:
          pallet_pose = interpolate_pose(p_row_start, p_row_end, column_alpha)
      end

      T_1approach_1 = pose_trans(inv(p_corner_1_approach), p_corners[0])
      approach_pose = pose_trans(pallet_pose, inv(T_1approach_1))

      return [approach_pose, pallet_pose]
  end

  ###################################################################################
  #
  # MOVE DOOR
  #
  ###################################################################################

  def rq_setup_door_force_node(reference_frame, force, stiffness):
    feature = 1
    forces = [force,0,0,0,0,0]
    max_negative_deviation = [-5, 0, 0, 0, 0, 0]
    max_positive_deviation = [0.01, 0, 0, 0, 0, 0] # using a large value here would allow the trajectory to violate the kinematics limits, using zero removes the force node effect
    stiffnesses = [stiffness, 100, 100, 100, 100, 100]
    enabled_axis = [True, False, False, False, False, False]
    is_adaptive = True

    force_node_id = rq_setup_machine_tending_force_node(feature, forces, stiffnesses, max_negative_deviation, max_positive_deviation, enabled_axis, is_adaptive)

    node_rpc_server.setCustomFixedForceFrame(force_node_id, [reference_frame[3],reference_frame[4],reference_frame[5]])

    return force_node_id
  end

  def json_rq_moves_node(tcp_speed, tcp_accel):
    json = "{"
    json = concat(json, key_val("offsetType", 0), ",")
    json = concat(json, key_val("tcpSpeed", tcp_speed), ",")
    json = concat(json, key_val("tcpAccel", tcp_accel), ",")
    json = concat(json, key_val("actualreferenceframe", [0, 0, 0, 0, 0, 0]), ",")
    json = concat(json, key_val("originalreferenceframe", [0, 0, 0, 0, 0, 0]), "}")
    return json
  end

  def rq_setup_rqmoves_node(parent_node_id, tcp_speed, tcp_accel):
    rq_moves_node_id = node_rpc_server.createnewrqmoves()
    node_rpc_server.fromjson(rq_moves_node_id, json_rq_moves_node(tcp_speed, tcp_accel))
    node_rpc_server.setparentid(rq_moves_node_id, parent_node_id)
    return rq_moves_node_id
  end

  def rq_setup_waypoint_node(pose, joints, is_straight, parent_node_id):
    def json_waypoint_node(pose, joints, is_straight):
      json = "{"
      json = concat(json, key_val("jointPositions", joints), ",")
      json = concat(json, key_val("tcpPose", [pose[0],pose[1],pose[2],pose[3],pose[4],pose[5]]), ",")
      json = concat(json, key_val("isStraight", bool_to_str(is_straight)), "}")
      return json
    end

    waypoint_node_id = node_rpc_server.createnewwaypointnode()
    node_rpc_server.fromjson(waypoint_node_id, json_waypoint_node(pose, joints, is_straight))
    node_rpc_server.setparentid(waypoint_node_id, parent_node_id)
    node_rpc_server.rqmovesaddwaypoint(parent_node_id, waypoint_node_id)
    return waypoint_node_id
  end

  def rq_setup_move_door(reference_frame, start_pose, start_joints, stop_pose, stop_joints, move_force, contact_force, tcp_speed=0.4, tcp_accel=0.4):

    stop_pose_in_start_frame = pose_trans(pose_inv(start_pose), stop_pose)

    seeks_contact = False
    stiffness = 10
    move_force_node_id = rq_setup_door_force_node(reference_frame, move_force, stiffness)
    rq_moves_node_id = rq_setup_rqmoves_node(move_force_node_id, tcp_speed, tcp_accel)
    waypoint_open = rq_setup_waypoint_node(start_pose, start_joints, False, rq_moves_node_id)
    waypoint_close = rq_setup_waypoint_node(stop_pose, stop_joints, True, rq_moves_node_id)
    seeks_contact = True
    stiffness = 100
    contact_force_node_id = rq_setup_door_force_node(reference_frame, contact_force, stiffness)

    rq_movej_node_id = node_rpc_server.createnewmovejnode()
    node_rpc_server.setparentid(rq_movej_node_id, move_force_node_id)

    return [move_force_node_id, rq_moves_node_id, waypoint_open, waypoint_close, contact_force_node_id, rq_movej_node_id]
  end

  def rq_move_door(start_pose, start_joints, stop_pose, stop_joints, move_force, contact_force, tcp_speed, tcp_accel, approach_pose, approach_joints, end_reached_threshold=0.001):

    reference_frame = list_to_pose(kinematics_rpc_server.reorientP1WithXTowardP2andZApproxP1Z(start_pose, stop_pose))

    node_ids = rq_setup_move_door(reference_frame, start_pose, start_joints, stop_pose, stop_joints, move_force, contact_force, tcp_speed, tcp_accel)

    move_force_node_id = node_ids[0]
    rq_moves_node_id = node_ids[1]
    start_waypoint_node_id = node_ids[2]
    end_waypoint_node_id = node_ids[3]
    contact_force_node_id = node_ids[4]
    rq_movej_node_id = node_ids[5]

    rq_wait_ft_sensor_steady(2000)
    zero_ftsensor()
    sleep(0.1)

    path_answer = node_rpc_server.rqmovesinit(rq_moves_node_id)
    verify_path_answer(path_answer)

    approach_position_joints = get_inverse_kin(approach_pose, qnear=approach_joints)
    movej(approach_position_joints)

    node_rpc_server.movejdefinewaypoint(rq_movej_node_id, get_actual_joint_positions(), 1.0, 1.0)
    node_rpc_server.setparentid(rq_movej_node_id, move_force_node_id)
    reset_node_executor()
    active_and_reset_node(move_force_node_id)
    node_execution_thread = execute_node(rq_movej_node_id, True)

    path_answer = node_rpc_server.rqmovesinit(rq_moves_node_id)
    verify_path_answer(path_answer)
    q0 = node_rpc_server.rqmovesgetfirstpoint(rq_moves_node_id)
    node_rpc_server.setparentid(rq_movej_node_id, move_force_node_id)
    node_rpc_server.movejdefinewaypoint(rq_movej_node_id, q0, 1.0, 0.4)
    execute_node(rq_movej_node_id)
    execute_node(start_waypoint_node_id)
    execute_node(end_waypoint_node_id)

    kill_thread(node_execution_thread)

    node_rpc_server.movejdefinewaypoint(rq_movej_node_id, get_actual_joint_positions(), 1.0, 1.0)
    node_rpc_server.setparentid(rq_movej_node_id, contact_force_node_id)
    reset_node_executor()
    active_and_reset_node(contact_force_node_id)
    node_execution_thread = execute_node(rq_movej_node_id, True)

    timeout = 20
    while (point_dist(get_actual_tcp_pose(), stop_pose) > end_reached_threshold):
      if (timeout <= 0):
        popup("Door has not reached its final position")
        halt
      else:
        sync()
        timeout = timeout - get_steptime()
      end
    end

    kill_thread(node_execution_thread)

    approach_pose_in_start_frame = pose_trans(pose_inv(start_pose), approach_pose)
    retract_pose = pose_trans(get_actual_tcp_pose(), approach_pose_in_start_frame)
    movej(retract_pose)

    node_rpc_server.deletenode(move_force_node_id)
    node_rpc_server.deletenode(rq_moves_node_id)
    node_rpc_server.deletenode(start_waypoint_node_id)
    node_rpc_server.deletenode(end_waypoint_node_id)
    node_rpc_server.deletenode(contact_force_node_id)
    node_rpc_server.deletenode(rq_movej_node_id)

  end

  ###################################################################################
  #
  # CNC Insertion
  #
  ###################################################################################

  def rq_collet_insertion(contact_pose, insert_pose, inserted_pose):
      movel(contact_pose, a=1.2, v=0.025)
      movel(insert_pose, a=1.2, v=0.025)

      zero_ftsensor()
      sleep(0.1)

      direction = "Z+"
      stop_force_threshold = 3.0
      max_radius = 5.0
      radius_incr = 0.7
      peck_mode = False
      tangential_speed = 0.02
      compliant_insert_force_threshold = 10.0
      spiral_initial_pose_offset_name = "spiral_initial_pose_offset_name"
      rq_ins_destination = inserted_pose
      max_distance = point_dist(inserted_pose, get_actual_tcp_pose())
      rq_spiral_not_completed = False
      rq_ins_speed_setting = 0.02

      rq_insert_spiral_urcap(direction, stop_force_threshold, max_radius, radius_incr, peck_mode, tangential_speed, compliant_insert_force_threshold, spiral_initial_pose_offset_name)

      if (rq_spiral_not_completed):
        return False
      end

      return True
  end

  def rq_push_part(approach_pose, chuck_pose):
      zero_ftsensor()
      sleep(0.1)

      # Find pose with z axis pointing in the direction of the insertion
      p1 = translate_to_origin(approach_pose)
      insertion_dir_in_base_frame = pose_trans(p1, pose_trans(pose_inv(approach_pose), chuck_pose))
      ref_frame_pose = list_to_pose(kinematics_rpc_server.poseFromZaxis([insertion_dir_in_base_frame[0], insertion_dir_in_base_frame[1], insertion_dir_in_base_frame[2]]))

      surface_found = rq_linear_search_custom_frame("Z+", 10.0, 0.025, 0.1, ref_frame_pose)

      if not(surface_found):
          return False
      end

      return True
  end

  def rq_place_in_chuck(close_chuck_do, open_chuck_do, chuck_approach, chuck_position, chuck_delay):
      rq_open_workholding(close_chuck_do, open_chuck_do)

      movel(chuck_approach, a=1.2, v=0.25)
      movel(chuck_position, a=1.2, v=0.25)

      rq_close_workholding(close_chuck_do, open_chuck_do)
      sleep(chuck_delay)
  end

  def rq_pre_pick_in_chuck(chuck_approach, chuck_position, speed=0.25, accel=1.2):
      movel(chuck_approach, accel, speed)
      movel(chuck_position, accel, speed)
  end

  def rq_post_pick_in_chuck(close_chuck_do, open_chuck_do, chuck_approach, chuck_position, chuck_delay, speed=0.25,
  accel=1.2):
      rq_open_workholding(close_chuck_do, open_chuck_do)
      sleep(chuck_delay)

      movel(chuck_approach, accel, speed)
  end

  def rq_open_workholding(close_do, open_do):
      rq_set_workholding_do(close_do, open_do, False)
  end

  def rq_close_workholding(close_do, open_do):
      rq_set_workholding_do(close_do, open_do, True)
  end

  def rq_set_workholding_do(close_do, open_do, close_request):
      is_close_do_valid = rq_is_do_valid(close_do)
      is_open_do_valid = rq_is_do_valid(open_do)

      if(is_close_do_valid):
          set_standard_digital_out(close_do, close_request)
      end
      if(is_open_do_valid):
          set_standard_digital_out(open_do, not close_request)
      end
      if(is_close_do_valid or is_open_do_valid):
          sleep(0.5)
      end
  end

  def rq_is_do_valid(do_id):
      return do_id >= 0 and do_id <= 7
  end

  def set_cleaning_digital_output(address, state, blow_off_mode, output_type):
     if(blow_off_mode == BLOW_OFF_MODE_SMART_AIR):
       rq_set_output(output_type, address, state)
     end
  end

  ###################################################################################
  #
  # PATH GENERATOR 6 POINTS CURVE BUILT WITH 2 POINTS
  #
  ###################################################################################

  def execute_half_pipe(pose_1, pose_2,pose_transformation_air_nozzle_to_actual_tcp, depth, length_distance, width, angle, speed, spacing, address, output_type, blow_off_mode, passes):
    path_gen_poses = get_path_generator_6_points_poses(pose_1, pose_2, pose_transformation_air_nozzle_to_actual_tcp, depth, length_distance, width, angle)
    start_pose = p[path_gen_poses[0,0],path_gen_poses[0,1],path_gen_poses[0,2],path_gen_poses[0,3],path_gen_poses[0,4],path_gen_poses[0,5]]
    path_generator_node_id = setup_path_generator_6_points(path_gen_poses, speed, spacing)
    execute_path_generator_6_points(path_generator_node_id, start_pose,  address, output_type, blow_off_mode, passes)
  end

  def get_path_generator_6_points_poses(pose_2, pose_5,pose_transformation_air_nozzle_to_actual_tcp, depth=0.01, length=0, width=0.05, angle_deg=0):

    def offset_pose(pose, offset, offset_reference_frame, pose_transformation_air_nozzle_to_actual_tcp):
      pose_relative_to_ref_frame = express_pose_A_relative_to_pose_B(pose, offset_reference_frame)
      ref_frame_with_offset = pose_trans(offset_reference_frame, offset)
      pose_with_offset = pose_trans(ref_frame_with_offset, pose_relative_to_ref_frame)
      pose_with_offset_for_actual_tcp = pose_trans(pose_with_offset, pose_transformation_air_nozzle_to_actual_tcp)
      return pose_to_list(pose_with_offset_for_actual_tcp)
    end

    if(length > 0):
      middle_pose = interpolate_pose(pose_2, pose_5, 0.5)

      poses = get_symmetric_poses_from_middle(pose_2, pose_5, middle_pose, length)
      pose_2 = poses[0]
      pose_5 = poses[1]
    end

    path_ref_frame = list_to_pose(kinematics_rpc_server.reorientP1WithXTowardP2andZApproxP1Z(pose_2, pose_5))

    offset1 = pose_add(p[0,0,0,0,d2r(angle_deg),0], p[0, width,-depth,-d2r(angle_deg),0,0])
    offset2 = pose_add(p[0,0,0,0,d2r(angle_deg),0], p[0,     0,     0,              0,0,0])
    offset3 = pose_add(p[0,0,0,0,d2r(angle_deg),0], p[0,-width,-depth, d2r(angle_deg),0,0])

    pose_1_array = offset_pose(pose_2, offset1, path_ref_frame, pose_transformation_air_nozzle_to_actual_tcp)
    pose_2_array = offset_pose(pose_2, offset2, path_ref_frame, pose_transformation_air_nozzle_to_actual_tcp)
    pose_3_array = offset_pose(pose_2, offset3, path_ref_frame, pose_transformation_air_nozzle_to_actual_tcp)

    pose_4_array = offset_pose(pose_5, offset1, path_ref_frame, pose_transformation_air_nozzle_to_actual_tcp)
    pose_5_array = offset_pose(pose_5, offset2, path_ref_frame, pose_transformation_air_nozzle_to_actual_tcp)
    pose_6_array = offset_pose(pose_5, offset3, path_ref_frame, pose_transformation_air_nozzle_to_actual_tcp)

    return [pose_1_array, pose_2_array, pose_3_array, pose_4_array, pose_5_array, pose_6_array]
  end

  def setup_path_generator_6_points(pose_list, tcp_speed=0.1, spacing=0.02):

    def json_path_generator_node(pose_list, tcp_speed, spacing):

      SIX_POINTS_CURVE = 3
      OFFSET_TYPE_NONE = 0
      FORCE_OPPOSITE_SIDE = 2

      json = "{"
      json = concat(json, key_val("tcpSpeed", tcp_speed), ",")
      json = concat(json, key_val("poses", pose_list), ",")
      json = concat(json, key_val("avoidAbruptEnd", "false"), ",")
      json = concat(json, key_val("isSurfaceFillOn", "true"), ",")
      json = concat(json, key_val("spacing", spacing), ",")
      json = concat(json, key_val("pathType", SIX_POINTS_CURVE), ",")
      json = concat(json, key_val("offsetType",OFFSET_TYPE_NONE), ",")
      json = concat(json, key_val("endingMode", FORCE_OPPOSITE_SIDE), "}")

      return json
    end

    rq_path_generator_parent_id = 0
    path_generator_node_id = node_rpc_server.createPathGeneratorNode()
    node_rpc_server.fromjson(path_generator_node_id, json_path_generator_node(pose_list, tcp_speed, spacing))
    node_rpc_server.setparentid(path_generator_node_id, rq_path_generator_parent_id)

    return path_generator_node_id
  end

  def execute_path_generator_6_points(path_generator_node_id, pose_1, address = INVALID_OUTPUT_ADDRESS, output_type = MODBUS_TYPE, blow_off_mode = BLOW_OFF_MODE_NO_AIR, passes = 1):
    index = 0
    while (index < passes):
      movej(get_inverse_kin(pose_1))
      set_cleaning_digital_output(address, True, blow_off_mode, output_type)
      reset_node_executor()
      node_execution_thread = execute_node(path_generator_node_id, True)
      rq_continue_node_execution = False
      set_cleaning_digital_output(address, False, blow_off_mode, output_type)
      join node_execution_thread
      index = index + 1
    end
    node_rpc_server.deletenode(path_generator_node_id)
  end

  ###################################################################################
  #
  # Straight line trajectory
  #
  ###################################################################################

  def execute_straight_line(p1, p2,pose_transformation_air_nozzle_to_actual_tcp, accel=1.2, speed=0.25, distance = 0, angles = [0, 0, 0], address = INVALID_OUTPUT_ADDRESS, output_type = MODBUS_TYPE, blow_off_mode = BLOW_OFF_MODE_NO_AIR, passes = 1):
    offset_for_angles = p[0, 0, 0, d2r(angles[0]), d2r(angles[1]), d2r(angles[2])]
    p1 = pose_trans(p1, offset_for_angles)
    p2 = pose_trans(p2, offset_for_angles)

    # apply transformation to take into account that the actual tcp offset is not the same as the one that was used when the waypoints were saved:
    p1 = pose_trans(p1, pose_transformation_air_nozzle_to_actual_tcp)
    p2 = pose_trans(p2, pose_transformation_air_nozzle_to_actual_tcp)
    global air_output_adress = address

    qActual = get_actual_joint_positions()
    CleanPathId = node_rpc_server.createnewcleaningpathnode(p1, p2, qActual, passes, distance, accel, speed, blow_off_mode)

    reset_node_executor()
    if output_type == MODBUS_TYPE:
      air_thread = run modbusAirControlThread()
    elif output_type == STANDARD_TYPE:
      air_thread = run standardAirControlThread()
    end

    node_execution_thread = execute_node(CleanPathId, True)
    rq_continue_node_execution = False

    join node_execution_thread
    node_rpc_server.deletenode(CleanPathId)
    if output_type == MODBUS_TYPE or output_type == STANDARD_TYPE :
      kill air_thread
    end
  end

  ###################################################################################
  #
  # Cross trajectory
  #
  ###################################################################################

  def find_cross_trajectory_poses(p1, p2, height=0, width=0, p1_angles = [0, 0, 0], p2_angles = [0, 0, 0], p3_angles = [0, 0, 0], p4_angles = [0, 0, 0]):
    def find_side_poses(p0, p1):
      def find_side_pose(p0,p1,angle):
        p1_T_p0 = pose_trans(pose_inv(p0), p1)
        rotated_p0_by_90_degrees = pose_trans(p0, p[0, 0, 0, 0, 0, d2r(angle)])

        side_pose = pose_trans(rotated_p0_by_90_degrees, p1_T_p0)
        side_pose[3] = p0[3]
        side_pose[4] = p0[4]
        side_pose[5] = p0[5]

        return side_pose
      end

      p3= find_side_pose(p0, p1, 90)
      p4 = find_side_pose(p0, p1, 270)

      return [p3, p4]
    end

    def get_start_and_end_poses_based_on_distance(p1, p2, middle_pose, distance):
      if(distance == 0):
        start_pose = p1
        end_pose = p2
      else:
        poses = get_symmetric_poses_from_middle(p1, p2, middle_pose, distance)
        start_pose = poses[0]
        end_pose = poses[1]
      end
      return [start_pose, end_pose]
    end

    def get_side_poses_based_on_distance(p1, p2, middle_pose, width):
      if(width == 0):
        side_poses = find_side_poses(middle_pose, p1)
      else:
        poses = get_symmetric_poses_from_middle(p1, p2, middle_pose, width)
        side_poses = find_side_poses(middle_pose, poses[0])
      end

      return side_poses
    end

    def get_angle_offset(angles):
      return  p[0, 0, 0, d2r(angles[0]), d2r(angles[1]), d2r(angles[2])]
    end

    middle_pose = interpolate_pose(p1, p2, 0.5)

    start_and_end_poses = get_start_and_end_poses_based_on_distance(p1, p2, middle_pose, height)
    side_poses = get_side_poses_based_on_distance(p1, p2, middle_pose, width)

    p1_offset = get_angle_offset(p1_angles)
    p2_offset = get_angle_offset(p2_angles)
    p3_offset = get_angle_offset(p3_angles)
    p4_offset = get_angle_offset(p4_angles)

    start_and_end_poses[0] = pose_trans(start_and_end_poses[0], p1_offset)
    start_and_end_poses[1] = pose_trans(start_and_end_poses[1], p2_offset)
    side_poses[0] = pose_trans(side_poses[0], p3_offset)
    side_poses[1] = pose_trans(side_poses[1], p4_offset)

    return [middle_pose, start_and_end_poses[0], start_and_end_poses[1], side_poses[0], side_poses[1]]
  end

  def execute_cross_trajectory(p1, p2,pose_transformation_air_nozzle_to_actual_tcp, height=0, width=0, p1_angles = [0, 0, 0], p2_angles = [0, 0, 0], p3_angles = [0, 0, 0], p4_angles = [0, 0, 0], accel=1.2, speed=0.25,  address = INVALID_OUTPUT_ADDRESS, output_type = MODBUS_TYPE, blow_off_mode = BLOW_OFF_MODE_NO_AIR, passes = 1):

    cross_poses = find_cross_trajectory_poses(p1, p2, height, width, p1_angles, p2_angles, p3_angles, p4_angles)

    p0 = pose_trans(cross_poses[0], pose_transformation_air_nozzle_to_actual_tcp)
    p1 = pose_trans(cross_poses[1], pose_transformation_air_nozzle_to_actual_tcp)
    p2 = pose_trans(cross_poses[2], pose_transformation_air_nozzle_to_actual_tcp)
    p3 = pose_trans(cross_poses[3], pose_transformation_air_nozzle_to_actual_tcp)
    p4 = pose_trans(cross_poses[4], pose_transformation_air_nozzle_to_actual_tcp)

   index = 0

   while (index < passes):
     movej(get_inverse_kin(p0))
     set_cleaning_digital_output(address, True, blow_off_mode, output_type)
     movel(p1, accel, speed)
     movel(p2, accel, speed)
     movel(p0, accel, speed)
     movel(p3, accel, speed)
     movel(p4, accel, speed)
     set_cleaning_digital_output(address, False, blow_off_mode, output_type)
     index = index + 1
   end
  end

  def execute_waypoint_cross_trajectory(starting_pose, finishing_pose, accel=1.2, speed=0.25):
   movej(get_inverse_kin(starting_pose))
   movel(finishing_pose, accel, speed)
  end

  ###################################################################################
  #
  # Fermat spiral trajectory
  #
  ###################################################################################

  def execute_fermat_spiral(start_pose, end_pose,pose_transformation_air_nozzle_to_actual_tcp, max_radius = 0, angle = 0, number_of_turns = 1, speed = 0.25,address = INVALID_OUTPUT_ADDRESS, output_type = MODBUS_TYPE, blow_off_mode = BLOW_OFF_MODE_NO_AIR, passes = 1):
    def find_middle(start_pose, end_pose):
      alpha = 0.5
      return interpolate_pose(start_pose, end_pose, alpha)
    end

    def find_next_theta(spiral_constant, theta, speed):
      denom = spiral_constant * sqrt(1/(4*theta) + theta)
      theta_dot = speed / denom
      theta = theta + theta_dot * rq_controller_time_step
      return theta
    end

    def find_spiral_pose(theta, spiral_plane, center_pose, angle, spiral_constant, pose_transformation_air_nozzle_to_actual_tcp):
      local r = spiral_constant * sqrt(theta)
      local x = r * cos(theta)
      local y = r * sin(theta)

      local p2 = pose_trans(spiral_plane, p[x,y,0,0,0,0])
      local p3 = p[p2[0], p2[1], p2[2], center_pose[3], center_pose[4], center_pose[5]]
      local p4 = pose_trans(p3, pose_transformation_air_nozzle_to_actual_tcp)
      local p5 = pose_trans(p4, p[0, 0, 0, -d2r(angle)*cos(theta), -d2r(angle)*sin(theta), 0])
      return p5
    end

    def execute_outer_to_inner_spiral(start_pose, middle_pose, spiral_plane, pose_transformation_air_nozzle_to_actual_tcp, max_angle, angle, spiral_constant_nominal, speed, address, output_type, blow_off_mode):
      local theta = max_angle
      local max_r = point_dist(start_pose, middle_pose)
      local spiral_constant = -1 * spiral_constant_nominal
      local r = max_r
      local is_first_pose = True

      while (norm((r)) <= max_r):
        theta = find_next_theta(spiral_constant, theta, speed)
        if(theta < 0):
          break
        end

        r = spiral_constant * sqrt(theta)
        next_pose = find_spiral_pose(theta, spiral_plane, middle_pose, angle, spiral_constant, pose_transformation_air_nozzle_to_actual_tcp)

        if (is_first_pose):
          movej(get_inverse_kin(next_pose))
          set_cleaning_digital_output(address, True, blow_off_mode, output_type)
          is_first_pose = False
        else:
          servoj(get_inverse_kin(next_pose), t = rq_controller_time_step)
        end
      end
    end

    def execute_inner_to_outer_spiral(start_pose, middle_pose, spiral_plane, pose_transformation_air_nozzle_to_actual_tcp, angle, spiral_constant, speed):
      local theta = 0.0001
      local max_r = point_dist(start_pose, middle_pose)
      local r = 0

      while (norm(r) <= max_r):
        theta = find_next_theta(spiral_constant, theta, speed)
        r = spiral_constant * sqrt(theta)
        next_pose = find_spiral_pose(theta, spiral_plane, middle_pose, angle, spiral_constant, pose_transformation_air_nozzle_to_actual_tcp)
        servoj(get_inverse_kin(next_pose), t = rq_controller_time_step)
      end
    end

    max_angle = d2r(number_of_turns * 360)
    middle_pose = find_middle(start_pose, end_pose)

    if(max_radius > 0):
      poses = get_symmetric_poses_from_middle(start_pose, end_pose, middle_pose, max_radius * 2)
      start_pose = poses[0]
      end_pose = poses[1]
    end

    SPIRAL_CONSTANT = (point_dist(middle_pose, start_pose)) / sqrt(max_angle)

    spiral_plane = list_to_pose(kinematics_rpc_server.reorientP1WithXTowardP2andZApproxP1Z(middle_pose, end_pose))


    index = 0
    while(index < passes):
      execute_outer_to_inner_spiral(start_pose, middle_pose, spiral_plane,pose_transformation_air_nozzle_to_actual_tcp, max_angle, angle, SPIRAL_CONSTANT, speed, address, output_type, blow_off_mode)
      execute_inner_to_outer_spiral(end_pose, middle_pose, spiral_plane, pose_transformation_air_nozzle_to_actual_tcp, angle, SPIRAL_CONSTANT, speed)
      set_cleaning_digital_output(address, False, blow_off_mode, output_type)
      index = index + 1
    end
  end

  ###################################################################################
  #
  # ROBOTIQ VISE INSERTION
  #
  # - The first touch is performed in the direction of the gravity, regardless of
  #   the robot mounting orientation, tcp offset and TCP orientation
  # - Optional 2e et 3e touch are performed relative to TCP. They require that, at
  #   the moment that the insertion is performed, the TCP is oriented such that one
  #   axis is aligned with the gravity. The TCP axes for the 2e and 3e touch are
  #   chosen as the ones not aligned with the gravity.
  ###################################################################################
  def insert_in_vise(start_pose, end_pose, number_of_touch=3, forces=[10, 20, 20], invert_axis=False, move_to_end_pose=False):

    def list_by_scalar_multiply_(l1, scalar):
      result = l1
      i=0
      while i<length(result):
        result[i]=l1[i]*scalar
        i=i+1
      end
      return result
    end

    def find_gravity_direction(acceleration_direction, threshold):
      result = [False, False, False]
      i = 0
      while i < length(result):
        result[i] =  norm(acceleration_direction[i]) > threshold
        i = i + 1
      end
      return result
    end

    def get_axis(index, direction):
      axis = "XYZ"
      if direction < 0:
        sign = "-"
      elif direction > 0:
        sign = "+"
      else:
        popup("insert_in_vise:get_axis >>> direction cannot be 0. Fix it.")
        halt
      end
      return str_cat(str_sub(axis, index, 1), sign)
    end

    def direction_to_index(str):
      if "X" == str_sub(str, 0, 1):
        return 0
      elif "Y" == str_sub(str, 0, 1):
        return 1
      elif "Z" == str_sub(str, 0, 1):
        return 2
      else:
        popup("invalid direction :", str)
        halt
      end
    end

    def find_touch_direction(mask, direction):
      i = 0
      result = [0, 0, 0]
      while i < 3:
        if mask[i]:
          result[i] = direction[i]
        end
        i = i + 1
      end
      return result
    end

    def find_touch_direction_str(mask, direction):
      i = 0
      result = ""
      while i < 3:
        if mask[i]:
          result = str_cat(result, get_axis(i, direction[i]))
        end
        i = i + 1
      end
      return result
    end

    def invert(list):
      result = list
      i = 0
      while i < length(list):
        result[i] = not list[i]
        i = i + 1
      end
      return result
    end

    def assert_that_the_first_touch_is_aligned_with_an_axis(first_touch_direction_mask):
      i = 0
      counter = 0
      while i < length(first_touch_direction_mask):
        if first_touch_direction_mask[i]:
          counter = counter + 1
        end
        i = i + 1
      end

      if counter != 1:
        popup("One of the TCP axes must be perpendicular to the floor while loading the part in the vise.")
        halt
      end
    end

    def setup_nodes(forces, number_of_touch, first_touch_direction_mask, direction, second_direction_str, third_direction_str):
      def max_deviation_from(forces, enabled_axis):
        i = 0
        deviation = [0, 0, 0, 0, 0, 0]
        while i < 3:
          if forces[i] > 0:
            deviation[i] = 10
          elif forces[i] ==  0:
            deviation[i] = 10
          end
          i = i + 1
        end
        while i < 6:
          if enabled_axis[i]:
            deviation[i] = 0.35
          end
          i = i + 1
        end
        return deviation
      end

      def min_deviation_from(forces, enabled_axis):
        i = 0
        deviation = [0, 0, 0, 0, 0, 0]
        while i < 3:
          if forces[i] < 0:
            deviation[i] = -10
          elif forces[i] ==  0:
            deviation[i] = -10
          end
          i = i + 1
        end
        while i < 6:
          if enabled_axis[i]:
            deviation[i] = -0.35
          end
          i = i + 1
        end
        return deviation
      end

      def stiffness_from(forces):
        i = 0
        stiffness = [0, 0, 0, 100, 100, 100]
        while i < length(forces):
          if norm(forces[i]) > 0:
            stiffness[i] = 100
          else:
            stiffness[i] = 85
          end
          i = i + 1
        end
        return stiffness
      end

      def compute_final_forces(forces, number_of_touch, first_touch_direction_mask, direction, second_direction_str, third_direction_str):
        final_forces = [0, 0, 0]
        if number_of_touch > 0:
          i = 0
          while i < length(first_touch_direction_mask):
            if first_touch_direction_mask[i]:
              break
            end
            i = i + 1
          end
          final_forces[i] = direction[i] * forces[i]
        end
        if number_of_touch > 1:
          i = direction_to_index(second_direction_str)
          final_forces[i] = direction[i] * forces[i]
        end
        if number_of_touch > 2:
          i = direction_to_index(third_direction_str)
          final_forces[i] = direction[i] * forces[i]
        end
        return final_forces
      end

      def compute_enabled_axis(first_touch_direction_mask):
        enabled_axis = [True, True, True, False, False, False]
        i = 0
        while i < length(first_touch_direction_mask):
          if first_touch_direction_mask[i]:
            break
          end
          i = i + 1
        end
        enabled_axis[i + 3] = True

        return enabled_axis
      end

      final_forces = compute_final_forces(forces, number_of_touch, first_touch_direction_mask, direction, second_direction_str, third_direction_str)
      enabled_axis = compute_enabled_axis(first_touch_direction_mask)

      force_node_id = rq_setup_machine_tending_force_node(1, [final_forces[0], final_forces[1], final_forces[2], 0, 0, 0], stiffness_from
      (final_forces), min_deviation_from(final_forces, enabled_axis), max_deviation_from(final_forces, enabled_axis), rq_bool_array_to_string(enabled_axis), "false")
      movej_node_id = node_rpc_server.createnewmovejnode()
      node_rpc_server.setparentid(movej_node_id, force_node_id)

      return [force_node_id, movej_node_id]
    end

    def average_tool_acceleration_reading(n_samples, delay):
      n = n_samples
      reading = [0, 0, 0]
      while n > 0:
        reading = reading + get_tool_accelerometer_reading()
        sleep(delay)
        n = n - 1
      end
      return reading/n_samples
    end

    def linear_search_toward_gravity(force):
      # maybe add a stopj here to prevent acceleration reading to be influenced by robot movement
      flange_accel = average_tool_acceleration_reading(10, 0.1) # measured accel is oriented in gravity oposite direction
      flange_accel_pose = p[-flange_accel[0], -flange_accel[1], -flange_accel[2], 0, 0,0]
      p1 = translate_to_origin(get_actual_tool_flange_pose())
      gravity_dir_in_base_frame = pose_trans(p1, flange_accel_pose)

      # Find pose with z axis pointing in gravity direction:
      ref_frame_pose = list_to_pose(kinematics_rpc_server.poseFromZaxis([gravity_dir_in_base_frame[0], gravity_dir_in_base_frame[1], gravity_dir_in_base_frame[2]]))
      speed = 0.01
      abs_max_distance = 0.05

      surface_found = rq_linear_search_custom_frame("Z+", force, speed, abs_max_distance, ref_frame_pose)
      return surface_found
    end

    #### Actual insert_in_vise method ####
    movel(start_pose)
    zero_ftsensor()

    # 1. Use accelerometer reading to find touches directions:
    ACCELERATION_THRESHOLD = 8
    flange_accel = average_tool_acceleration_reading(10, 0.1)
    tcp_accel = pose_trans(pose_inv(get_tcp_offset()), p[flange_accel[0], flange_accel[1], flange_accel[2], 0, 0, 0])
    first_touch_direction_mask = find_gravity_direction(tcp_accel, ACCELERATION_THRESHOLD)
    assert_that_the_first_touch_is_aligned_with_an_axis(first_touch_direction_mask)

    direction_transform = pose_trans(pose_inv(start_pose), end_pose)
    direction = [direction_transform[0], direction_transform[1], direction_transform[2]]
    direction_sign = [direction[0]/norm(direction[0]), direction[1]/norm(direction[1]), direction[2]/norm(direction[2])]

    touch_direction_str = find_touch_direction_str(invert(first_touch_direction_mask), direction_sign)
    touch_direction = find_touch_direction(invert(first_touch_direction_mask), direction_sign)

    if invert_axis:
      second_direction_str = str_sub(touch_direction_str, 0, 2)
      third_direction_str = str_sub(touch_direction_str, 2, 4)
    else:
      second_direction_str = str_sub(touch_direction_str, 2, 4)
      third_direction_str = str_sub(touch_direction_str, 0, 2)
    end

    end_pose_orientation = translate_to_origin(end_pose)

    # 2. Prepare nodes:
    rq_cnc_insertion_node_ids = setup_nodes(forces, number_of_touch, first_touch_direction_mask, direction_sign, second_direction_str, third_direction_str)
    feature_tool = 1

    # 3. Perform touches:
    if number_of_touch > 0:
      surface_found = linear_search_toward_gravity(forces[0])
      if not surface_found:
        textmsg("Insertion in vise: First contact has not been found")
        popup("First contact has not been found", title="Insertion in vise", blocking=True)
        return UNDEFINED_THREAD_ID
      end
    end
    if number_of_touch > 1:
      surface_found = rq_linear_search_urcap(second_direction_str, forces[1], 0.01, 0.05, feature_tool)
      if not surface_found:
        textmsg("Insertion in vise: Second contact has not been found")
        popup("Second contact has not been found", title="Insertion in vise", blocking=True)
        return UNDEFINED_THREAD_ID
      end
    end
    if number_of_touch > 2:
      surface_found = rq_linear_search_urcap(third_direction_str, forces[2], 0.01, 0.05, feature_tool)
      if not surface_found:
        textmsg("Insertion in vise: Third contact has not been found")
        popup("Third contact has not been found", title="Insertion in vise", blocking=True)
        return UNDEFINED_THREAD_ID
      end
    end

    # 4. Move to end position:
    if not move_to_end_pose:
      end_pose = get_actual_tcp_pose()
    end

    node_rpc_server.movejdefinewaypoint(rq_cnc_insertion_node_ids[1], get_actual_joint_positions(), 1.0, 1.0)
    reset_node_executor()
    active_and_reset_node(rq_cnc_insertion_node_ids[0])
    node_execution_thread = execute_node(rq_cnc_insertion_node_ids[1], True)
    node_rpc_server.movejdefinewaypoint(rq_cnc_insertion_node_ids[1], get_inverse_kin(end_pose), 1.0, 1.0)
    execute_node(rq_cnc_insertion_node_ids[1])
    sleep(1)
    return node_execution_thread
  end

  ###################################################################################
  # AIR OUTPUT CONTROL
  ###################################################################################
  thread modbusAirControlThread():
    while (True):
      rq_air_value = read_input_boolean_register(101)
      modbus_set_output_signal(air_output_adress, rq_air_value, False)
      sleep(rq_controller_time_step)
    end
  end

  thread standardAirControlThread():
    while (True):
      rq_air_value = read_input_boolean_register(101)
      set_digital_out(air_output_adress, rq_air_value)
      sleep(rq_controller_time_step)
    end
  end
  def rq_set_output(output_type, address, value):
    if output_type == "MODBUS":
      modbus_set_output_signal(address, value)
    elif output_type == "STANDARD":
      set_standard_digital_out(address, value)
    end
  end

  def rq_digital_output_action(action, output_type, address, time_on=1, time_off=0.5, delay_after=0):
    if action == "PUSH_AND_HOLD":
      rq_set_output(output_type, address, True)
    elif action == "PUSH":
      rq_set_output(output_type, address, True)
      sleep(time_on)
      rq_set_output(output_type, address, False)
    elif action == "DOUBLE_PUSH":
      rq_set_output(output_type, address, True)
      sleep(time_on)
      rq_set_output(output_type, address, False)
      sleep(time_off)
      rq_set_output(output_type, address, True)
      sleep(time_on)
      rq_set_output(output_type, address, False)
    elif action == "RELEASE":
      rq_set_output(output_type, address, False)
    end
    sleep(delay_after)
  end
  def json_kinematic_parameters_ratio(ratio):
    json = "{"
    json = concat(json, key_val("kinematicParametersRatio", ratio), "}")
    return json
  end

  def execute_move_along_trail(trail_node_id, joint_positions, kinematic_parameters_ratio):
    node_rpc_server.fromjson(trail_node_id, json_kinematic_parameters_ratio(kinematic_parameters_ratio))
    roadmap_state = node_rpc_server.initRoadmap(trail_node_id, joint_positions)
    path_time = roadmap_state[0]

    if(path_time > 0.0):
      reset_node_executor()
      node_execution_thread = execute_node(trail_node_id, True)
      kill node_execution_thread
    end
  end
    global servojId = 2
  rq_collision_detection_stop()
  # end: URCap Installation Node
  step_count_03902cba_4b48_4b48_94cf_afb1c372e4ff = 0.0
  thread Step_Counter_Thread_9d87483f_43ce_455f_a209_883264dba49d():
    while (True):
      step_count_03902cba_4b48_4b48_94cf_afb1c372e4ff = step_count_03902cba_4b48_4b48_94cf_afb1c372e4ff + 1.0
      sync()
    end
  end
  run Step_Counter_Thread_9d87483f_43ce_455f_a209_883264dba49d()
  global Waypoint_1_p=p[.335640862792, .245605837722, .240509363136, -3.141247049144, .000030873457, -.000264950718]
  global Waypoint_1_q=[3.518606662750244, -1.9488045177855433, 1.815993611012594, -1.436782107954361, -1.5680578390704554, -1.1988900343524378]
  global above_hole_p=p[.335648849220, .320063101769, .158270010534, -3.141206361577, .000048171891, -.000318242230]
  global above_hole_q=[3.7027668952941895, -1.8056603870787562, 1.9299371878253382, -1.6939622364439906, -1.5676897207843226, -1.0140412489520472]
  global on_hole_p=p[.335681183988, .320033529671, .132085702600, -3.141185491640, .000127799187, -.000446321232]
  global on_hole_q=[3.7027504444122314, -1.795096059838766, 1.9896605650531214, -1.7643300495543421, -1.5676177183734339, -1.013885800038473]
  def calculate_point_to_move_towards(feature, direction, position_distance):
    local posDir=[direction[0], direction[1], direction[2]]
    if (norm(posDir) < 1e-6):
      return get_target_waypoint()
    end
    local direction_vector_normalized=normalize(posDir)
    local displacement_pose=p[direction_vector_normalized[0] * position_distance,direction_vector_normalized[1] * position_distance,direction_vector_normalized[2] * position_distance,0,0,0]
    local wanted_displacement_in_base_frame=pose_sub(pose_trans(feature, displacement_pose), feature)
    return pose_add(get_target_waypoint(), wanted_displacement_in_base_frame)
  end
  global on_hole_2_p=p[.335878045774, .320731746432, .132106319572, -3.141241766844, .000131112261, -.000351829959]
  global on_hole_2_q=[3.704005002975464, -1.7932545147337855, 1.988183323537008, -1.764613767663473, -1.5676339308368128, -1.0126236120807093]
  $ 2 "BeforeStart"
  $ 3 "MoveJ"
  $ 4 "Waypoint_1" "breakAfter"
  movej(get_inverse_kin(Waypoint_1_p, qnear=Waypoint_1_q), a=1.3962634015954636, v=1.0471975511965976)
  while (True):
    $ 5 "Robot Program"
    $ 6 "rq_screw_vacuum_on()"
     rq_screw_vacuum_on ()
    $ 7 "Popup: Add insert"
    popup("Add insert", "Message", False, False, blocking=True)
    $ 8 "MoveJ"
    $ 9 "above_hole" "breakAfter"
    movej(get_inverse_kin(above_hole_p, qnear=above_hole_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 10 "on_hole" "breakAfter"
    movej(get_inverse_kin(on_hole_p, qnear=on_hole_q), a=1.3962634015954636, v=1.0471975511965976)
    # begin: URCap Program Node
    #   Source: Robotiq_Screwdriving, 2.2.3.37910-alpha, Robotiq Inc.
    #   Type: Drive Screw
    $ 11 "Drive Screw"
    rq_operation_mode = RQ_MODE_NORMAL
    rq_regulation_mode = RQ_REGULATION_MODE_CURRENT_WITH_RAMP_DOWN
    rq_rotation_current = 30
    rq_rotation_speed = 100
    rq_rotation_angle = 1197
    rq_teach_thread_mating_position = p[0.3358571246996078, 0.3200813392125644, 0.1318888242204277, -3.14088180381315, 1.4901171715672826E-4, -0.001505484901946036]
    rq_teach_final_position = p[0.33574183730424734, 0.3200829252058823, 0.12663880454164606, -3.1408982631825952, 1.701079722584559E-4, -9.392136887126088E-4]
    rq_torque_threshold = 2152
    rq_torque_angle_slope = 1403
    rq_force = 10.0
    rq_timeout = 10.0
    rq_distance_tolerance = -1.0
    rq_direction = RQ_DIRECTION_CW
    rq_screw_result = rq_screw_with_force(rq_operation_mode, rq_regulation_mode, rq_rotation_current, rq_rotation_speed,
    rq_rotation_angle, rq_teach_thread_mating_position, rq_teach_final_position, RQ_TEACHING_OFF, rq_torque_threshold,
    rq_torque_angle_slope, rq_force, rq_timeout, rq_distance_tolerance, rq_direction)
    # begin: URCap Program Node
    #   Source: Robotiq_Screwdriving, 2.2.3.37910-alpha, Robotiq Inc.
    #   Type: Robotiq Folder Node
    $ 12 "If success" "noBreak"
    if (rq_screw_result == RQ_SCREW_SUCCESS):
    $ 13 "'Insert If Success Instructions'" "noBreak"
    # 'Insert If Success Instructions'
    $ 14 "MoveL" "noBreak"
    $ 15 "Direction: Tool Z-" "noBreak"
    global move_thread_flag_15=0
    thread move_thread_15():
      enter_critical
      move_thread_flag_15 = 1
      local towardsPos=calculate_point_to_move_towards(get_forward_kin(), [0.0,0.0,-1.0], 0.005)
      movel(towardsPos, a=1.2, v=0.25)
      move_thread_flag_15 = 2
      exit_critical
    end
    move_thread_flag_15 = 0
    move_thread_han_15 = run move_thread_15()
    while (True):
      sleep(1.0E-10)
      if (move_thread_flag_15 > 1):
        join move_thread_han_15
        $ 16 "Until (distance)" "noBreak"
        break
      end
      sync()
    end
    rq_stop_regulating_and_stop_vacuum()
    end
    # end: URCap Program Node
    # begin: URCap Program Node
    #   Source: Robotiq_Screwdriving, 2.2.3.37910-alpha, Robotiq Inc.
    #   Type: Robotiq Folder Node
    $ 17 "If fail" "noBreak"
    if (rq_screw_result != RQ_SCREW_SUCCESS):
    # begin: URCap Program Node
    #   Source: Robotiq_Screwdriving, 2.2.3.37910-alpha, Robotiq Inc.
    #   Type: Robotiq Folder Node
    $ 18 "No screw detected" "noBreak"
    if (rq_screw_result == RQ_SCREW_FAIL_ON_SCREW_NOT_DETECTED):
    $ 19 "Popup: No screw detected" "noBreak"
    popup("No screw detected", "Error", False, True, blocking=True)
    # end: URCap Program Node
    # begin: URCap Program Node
    #   Source: Robotiq_Screwdriving, 2.2.3.37910-alpha, Robotiq Inc.
    #   Type: Robotiq Folder Node
    $ 20 "Timeout reached" "noBreak"
    elif (rq_screw_result == RQ_SCREW_FAIL_ON_TIME_MAX):
    $ 21 "Popup: Timeout reached" "noBreak"
    popup("Timeout reached", "Error", False, True, blocking=True)
    # end: URCap Program Node
    # begin: URCap Program Node
    #   Source: Robotiq_Screwdriving, 2.2.3.37910-alpha, Robotiq Inc.
    #   Type: Robotiq Folder Node
    $ 22 "Screwdriver not activated" "noBreak"
    elif (rq_screw_result == RQ_SCREW_FAIL_ON_SCREWDRIVER_NOT_ACTIVATED):
    $ 23 "Popup: Screwdriver Not Activated" "noBreak"
    popup("Screwdriver Not Activated", "Error", False, True, blocking=True)
    # end: URCap Program Node
    # begin: URCap Program Node
    #   Source: Robotiq_Screwdriving, 2.2.3.37910-alpha, Robotiq Inc.
    #   Type: Robotiq Folder Node
    $ 24 "Unhandled errors" "noBreak"
    else:
    $ 25 "Popup: Unhandled Screwdriving Error: Open Log tab for information on application warnings, and refer to the Screwdriver instruction manual to manage faults." "noBreak"
    popup("Unhandled Screwdriving Error: Open Log tab for information on application warnings, and refer to the Screwdriver instruction manual to manage faults.", "Error", False, True, blocking=True)
    end
    # end: URCap Program Node
    end
    # end: URCap Program Node
    # end: URCap Program Node
    $ 26 "MoveJ"
    $ 27 "above_hole" "breakAfter"
    movej(get_inverse_kin(above_hole_p, qnear=above_hole_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 28 "Waypoint_1" "breakAfter"
    movej(get_inverse_kin(Waypoint_1_p, qnear=Waypoint_1_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 29 "rq_screw_vacuum_on()"
     rq_screw_vacuum_on ()
    $ 30 "Popup: Flip part and add new insert."
    popup("Flip part and add new insert.", "Message", False, False, blocking=True)
    $ 31 "MoveJ"
    $ 32 "above_hole" "breakAfter"
    movej(get_inverse_kin(above_hole_p, qnear=above_hole_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 33 "on_hole_2" "breakAfter"
    movej(get_inverse_kin(on_hole_2_p, qnear=on_hole_2_q), a=1.3962634015954636, v=1.0471975511965976)
    # begin: URCap Program Node
    #   Source: Robotiq_Screwdriving, 2.2.3.37910-alpha, Robotiq Inc.
    #   Type: Drive Screw
    $ 34 "Drive Screw"
    rq_operation_mode = RQ_MODE_NORMAL
    rq_regulation_mode = RQ_REGULATION_MODE_CURRENT_WITH_RAMP_DOWN
    rq_rotation_current = 30
    rq_rotation_speed = 100
    rq_rotation_angle = 1197
    rq_teach_thread_mating_position = p[0.3358571246996078, 0.3200813392125644, 0.1318888242204277, -3.14088180381315, 1.4901171715672826E-4, -0.001505484901946036]
    rq_teach_final_position = p[0.33574183730424734, 0.3200829252058823, 0.12663880454164606, -3.1408982631825952, 1.701079722584559E-4, -9.392136887126088E-4]
    rq_torque_threshold = 2152
    rq_torque_angle_slope = 1403
    rq_force = 10.0
    rq_timeout = 10.0
    rq_distance_tolerance = -1.0
    rq_direction = RQ_DIRECTION_CW
    rq_screw_result = rq_screw_with_force(rq_operation_mode, rq_regulation_mode, rq_rotation_current, rq_rotation_speed,
    rq_rotation_angle, rq_teach_thread_mating_position, rq_teach_final_position, RQ_TEACHING_OFF, rq_torque_threshold,
    rq_torque_angle_slope, rq_force, rq_timeout, rq_distance_tolerance, rq_direction)
    # begin: URCap Program Node
    #   Source: Robotiq_Screwdriving, 2.2.3.37910-alpha, Robotiq Inc.
    #   Type: Robotiq Folder Node
    $ 35 "If success" "noBreak"
    if (rq_screw_result == RQ_SCREW_SUCCESS):
    $ 36 "'Insert If Success Instructions'" "noBreak"
    # 'Insert If Success Instructions'
    $ 37 "MoveL" "noBreak"
    $ 38 "Direction: Tool Z-" "noBreak"
    global move_thread_flag_38=0
    thread move_thread_38():
      enter_critical
      move_thread_flag_38 = 1
      local towardsPos=calculate_point_to_move_towards(get_forward_kin(), [0.0,0.0,-1.0], 0.005)
      movel(towardsPos, a=1.2, v=0.25)
      move_thread_flag_38 = 2
      exit_critical
    end
    move_thread_flag_38 = 0
    move_thread_han_38 = run move_thread_38()
    while (True):
      sleep(1.0E-10)
      if (move_thread_flag_38 > 1):
        join move_thread_han_38
        $ 39 "Until (distance)" "noBreak"
        break
      end
      sync()
    end
    rq_stop_regulating_and_stop_vacuum()
    end
    # end: URCap Program Node
    # begin: URCap Program Node
    #   Source: Robotiq_Screwdriving, 2.2.3.37910-alpha, Robotiq Inc.
    #   Type: Robotiq Folder Node
    $ 40 "If fail" "noBreak"
    if (rq_screw_result != RQ_SCREW_SUCCESS):
    # begin: URCap Program Node
    #   Source: Robotiq_Screwdriving, 2.2.3.37910-alpha, Robotiq Inc.
    #   Type: Robotiq Folder Node
    $ 41 "No screw detected" "noBreak"
    if (rq_screw_result == RQ_SCREW_FAIL_ON_SCREW_NOT_DETECTED):
    $ 42 "Popup: No screw detected" "noBreak"
    popup("No screw detected", "Error", False, True, blocking=True)
    # end: URCap Program Node
    # begin: URCap Program Node
    #   Source: Robotiq_Screwdriving, 2.2.3.37910-alpha, Robotiq Inc.
    #   Type: Robotiq Folder Node
    $ 43 "Timeout reached" "noBreak"
    elif (rq_screw_result == RQ_SCREW_FAIL_ON_TIME_MAX):
    $ 44 "Popup: Timeout reached" "noBreak"
    popup("Timeout reached", "Error", False, True, blocking=True)
    # end: URCap Program Node
    # begin: URCap Program Node
    #   Source: Robotiq_Screwdriving, 2.2.3.37910-alpha, Robotiq Inc.
    #   Type: Robotiq Folder Node
    $ 45 "Screwdriver not activated" "noBreak"
    elif (rq_screw_result == RQ_SCREW_FAIL_ON_SCREWDRIVER_NOT_ACTIVATED):
    $ 46 "Popup: Screwdriver Not Activated" "noBreak"
    popup("Screwdriver Not Activated", "Error", False, True, blocking=True)
    # end: URCap Program Node
    # begin: URCap Program Node
    #   Source: Robotiq_Screwdriving, 2.2.3.37910-alpha, Robotiq Inc.
    #   Type: Robotiq Folder Node
    $ 47 "Unhandled errors" "noBreak"
    else:
    $ 48 "Popup: Unhandled Screwdriving Error: Open Log tab for information on application warnings, and refer to the Screwdriver instruction manual to manage faults." "noBreak"
    popup("Unhandled Screwdriving Error: Open Log tab for information on application warnings, and refer to the Screwdriver instruction manual to manage faults.", "Error", False, True, blocking=True)
    end
    # end: URCap Program Node
    end
    # end: URCap Program Node
    # end: URCap Program Node
    $ 49 "MoveJ"
    $ 50 "above_hole" "breakAfter"
    movej(get_inverse_kin(above_hole_p, qnear=above_hole_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 51 "Halt"
    halt
  end
end
